<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <title>Linked Data Templates</title>
    <script
     src='https://www.w3.org/Tools/respec/respec-w3c-common'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Martynas Jusevičius",
          url: "http://atomgraph.com",
        }],
        processVersion: 2015,
        edDraftURI: "https://github.com/AtomGraph/Linked-Data-Templates/",
        shortName: "ldt",
        wg: "Declarative Linked Data Apps Community Group",
        wgURI: "https://www.w3.org/community/declarative-apps/",
        wgPublicList: "public-declarative-apps"
      };
    </script>
    <style type="text/css">
    </style>
  </head>
  <body>
    <!-- https://www.w3.org/TR/qaframe-spec/ -->
    <section id="abstract">
      <p>Linked Data Templates is a uniform protocol for read-write Linked Data. This document defines an abstract syntax (a data model) of Linked Data applications with SPARQL backends, and semantics of CRUD interactions against their resources.</p>
    </section>
    <section id="sotd">
    </section>
    <section id="introduction" class="informative">
      <h2>Introduction</h2>
      <p>This document defines a precise semantics for Linked Data applications, providing a specification of how Create, Read, Update, Delete (CRUD) interactions change the state of their resources.</p>
      <figure id="architecture">
        <img src="images/components.svg" alt="LDT architecture">
        <figcaption>Main components of LDT architecture</figcaption>
      </figure>
      <section>
        <h3>Applications</h3>
        <p>An LDT application represents a data space identified by its base URI, in which application resource URIs are relative to the base URI. The only external interface an application provides is RESTful Linked Data: application produces RDF representations when resource URIs are dereferenced, and consumes RDF representations when requested to change resource state.</p>
      </section>
      <section>
        <h3>Services</h3>
      </section>
      <section>
        <h3>Ontologies</h3>
      </section>
    </section>
    <section id="conformance">
    </section>
    <section id="abstract-syntax">
      <h2>Abstract syntax</h2>
      <p>This section defines the data model of LDT applications.</p>
      <section id="rest">
        <h3>REST</h3>
        <p>In this section we define the abstract syntax REpresentational State Transfer. It sufficient to model a RESTful read-write API independently of the transport protocol.</p>
        <dl>
          <dt><dfn>Request</dfn></dt>
          <dd>∈ Request</dd>
          <dt><dfn>Response</dfn></dt>
          <dd>∈ Response</dd>
          <dt><dfn>Body</dfn></dt>
          <dd>∈ Message-body</dd>
          <dt><dfn>MediaType</dfn></dt>
          <dd>∈ Media-type</dd>
          <dt><dfn>Status</dfn></dt>
          <dd>∈ Status</dd>
          <dt><dfn>IRI</dfn></dt>
          <dd>∈ Absolute-IRI</dd>
          <dt><dfn>Method</dfn></dt>
          <dd>∈ Interaction-method</dd>
        </dl>
        <pre class="grammar"><a>Request</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>Body</a>
<a>Response</a> := <a>Status</a> <a>Body</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
      <section id="linked-data">
        <h3>Linked Data</h3>
        <p>In this section, we specialize the REST abstract syntax by constraining the request/response representations to syntaxes of the RDF data model.</p>
        <dl>
          <dt><dfn>RDFRequest</dfn></dt>
          <dd>∈ RDF-Request ⊂ <a>Request</a></dd>
          <dt><dfn>RDFResponse</dfn></dt>
          <dd>∈ RDF-Response ⊂ <a>Response</a></dd>
          <dt><dfn>RDFBody</dfn></dt>
          <dd>∈ RDF-body ⊂ <a>Body</a></dd>
          <dt><dfn>RDFMediaType</dfn></dt>
          <dd>∈ RDF-media-type ⊂ <a>MediaType</a></dd>
		  <dt><dfn>Dataset</dfn></dt>
          <dd>∈ RDF-dataset</dd>
        </dl><pre><a>RDFBody</a>     := <a>Dataset</a> <a>RDFMediaType</a>
<a>RDFRequest</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>RDFBody</a>	
<a>RDFResponse</a> := <a>Status</a> <a>RDFBody</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
    </section>
    <section id="semantics">
      <h2>Semantics</h2>
      <section id="domains">
        <h3>Domains</h3>
        <dl>
          <dt><a>IRI</a></dt>
          <dd>= absolute IRI identifier</dd>
          <dt><dfn>Ontology</dfn></dt>
          <dd>= { <a>Operation</a>1, …, <a>Operation</a>N }</dd>
          <dt><a>Dataset</a></dt>
          <dd>= RDF dataset</dd>
          <dt><dfn>App</dfn></dt>
          <dd>= <a>IRI</a> × <a>Ontology</a> × <a>Dataset</a></dd>
          <dt><dfn>QueryBinding</dfn></dt>
          <dd>= Query Variable × RDFTerm</dd>
          <dt><dfn>Query</dfn></dt>
          <dd>= Describe + Construct = SPARQL query</dd>
          <dt><dfn>Update</dfn></dt>
          <dd>= Delete + InsertData</dd>
          <dt><dfn>Command</dfn></dt>
          <dd>= <a>Query</a> + <a>Update</a></dd>
          <dt><dfn>IRIPattern</dfn></dt>
          <dd>= URI template</dd>
          <dt><dfn>ReadCommand</dfn></dt>
          <dd>= { <code>Read</code> } × <a>Query</a></dd>
          <dt><dfn>WriteCommand</dfn></dt>
          <dd>= { <code>Create</code>, <code>Delete</code>, <code>Update</code> } × <a>Update</a></dd>
          <dt><dfn>Operation</dfn></dt>
          <dd><del>= <a>IRIPattern</a> × <a>Method</a> × <a>Command</a> × Priority</del></dd>
          <dd>= <a>IRIPattern</a> × (<a>ReadCommand</a> + <a>WriteCommand</a>) × Priority</dd>
          <dt><a>Status</a></dt>
          <dd>= { <code>NotFound</code>, <code>Created</code>, <code>NoContent</code>, <code>OK</code> }</dd>
          <dt><a>Method</a></dt>
          <dd>= { <code>Create</code>, <code>Read</code>, <code>Delete</code>, <code>Update</code> }</dd>
          <dt><a>RDFRequest</a></dt>
          <dd>= <a>Method</a> × <a>IRI</a> × <a>Dataset</a></dd>
      </dl>
      </section>
      <section id="functions">
        <h3>Functions</h3>
      </section>
      <section id="valuation-functions">
        <h3>Valuation functions</h3>
      </section>
    </section>
    <section id="ldt-http">
      <h2>LDT over HTTP</h2>
      <section>
        <h3>Concrete syntax</h3>
        <p class="ednote">Link abstract syntax to HTTP ABNF?</p>
      </section>
      <section id="valuation-examples">
        <h3>Valuation examples</h3>
        <section id="get-request">
          <h4>GET request</h4>
        </section>
        <section id="post-request">
          <h4>POST request</h4>
        </section>
        <section id="put-request">
          <h4>PUT request</h4>
        </section>
        <section id="delete-request">
          <h4>DELETE request</h4>
        </section>
      </section>
    </section>
    <section id="vocabulary">
      <h3>Vocabulary</h3>
      <section id="application">
        <h4>Application</h4>
	  </section>
	  <section id="template">
        <h4>Template</h4>
        <pre><strong>ldt:Template</strong>
  rdfs:subClassOf* = rdfs:Class
  <strong>ldt:path = xsd:string</strong>
  <strong>ldt:query = ldt:Query</strong>
  ldt:update? = ldt:Update
  ldt:lang? = rdf:langString
  ldt:cacheControl? = xsd:string
  spin:constructor? = spin:Rule
  rdfs:isDefinedBy = ldt:Ontology</pre>
      </section>
    </section>
  </body>
</html>
