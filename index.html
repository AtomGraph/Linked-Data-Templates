<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Linked Data Templates</title>
    <script
     src='https://www.w3.org/Tools/respec/respec-w3c-common'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Martynas Jusevičius",
          url: "http://atomgraph.com",
        }],
        processVersion: 2015,
        edDraftURI: "https://github.com/AtomGraph/Linked-Data-Templates/",
        shortName: "ldt",
        wg: "Declarative Linked Data Apps Community Group",
        wgURI: "https://www.w3.org/community/declarative-apps/",
        wgPublicList: "public-declarative-apps"
      };
    </script>
    <style type="text/css">
    </style>
  </head>
  <body>
    <!-- https://www.w3.org/TR/qaframe-spec/ -->
    <section id="abstract">
      <p>Linked Data Templates is a uniform protocol for read-write Linked Data. This document defines an abstract syntax (a data model) of Linked Data applications with SPARQL backends, and semantics of CRUD interactions against their resources.</p>
    </section>
    <section id="sotd">
    </section>
    <section id="introduction" class="informative">
      <h2>Introduction</h2>
      <p>This document defines a precise semantics for Linked Data applications, providing a specification of how Create, Read, Update, Delete (CRUD) interactions change the state of their resources.</p>
      <figure id="architecture">
        <img src="https://raw.githubusercontent.com/AtomGraph/Linked-Data-Templates/master/XML%20London%202016%20paper/images/components.svg" alt="LDT architecture">
        <figcaption>Main components of LDT architecture</figcaption>
      </figure>
      <section>
        <h3>Applications</h3>
        <p>An LDT application represents a data space identified by its base URI, in which application resource URIs are relative to the base URI. The only external interface an application provides is RESTful Linked Data: application produces RDF representations when resource URIs are dereferenced, and consumes RDF representations when requested to change resource state.</p>
      </section>
      <section>
        <h3>Services</h3>
      </section>
      <section>
        <h3>Ontologies</h3>
      </section>
    </section>
    <section>
      <h2>Conformance</h2>
      <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]]. As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative.</p>
    </section>
    <section>
      <h2>Abstract syntax</h2>
      <p>This section defines the data model of LDT applications.</p>
      <section>
        <h3>REST</h3>
        <p>In this section we define the abstract syntax REpresentational State Transfer. It sufficient to model a RESTful read-write API independently of the transport protocol.</p>
        <dl>
          <dt><dfn>Request</dfn></dt>
          <dd>∈ Request</dd>
          <dt><dfn>Response</dfn></dt>
          <dd>∈ Response</dd>
          <dt><dfn>Body</dfn></dt>
          <dd>∈ Message-body</dd>
          <dt><dfn>MediaType</dfn></dt>
          <dd>∈ Media-type</dd>
          <dt><dfn>Status</dfn></dt>
          <dd>∈ Status</dd>
          <dt><dfn>IRI</dfn></dt>
          <dd>∈ Absolute-IRI</dd>
          <dt><dfn>Method</dfn></dt>
          <dd>∈ Interaction-method</dd>
        </dl>
        <pre class="grammar"><a>Request</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>Body</a>
<a>Response</a> := <a>Status</a> <a>Body</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
      <section>
        <h3>Linked Data</h3>
        <p>In this section, we specialize the REST abstract syntax by constraining the request/response representations to syntaxes of the RDF data model.</p>
        <pre><dfn>Dataset</dfn>      ∈ RDF-dataset
<dfn>RDFMediaType</dfn> ∈ RDF media types

RDFBody     := Dataset RDFMediaType
RDFRequest  := Method IRI Dataset
RDFResponse := Status Dataset | Status IRI</pre>
      </section>
    </section>
    <section>
      <h2>Semantics</h2>
      <section>
        <h3>Domains</h3>
      </section>
      <section>
        <h3>Functions</h3>
      </section>
      <section>
        <h3>Valuation functions</h3>
      </section>
    </section>
    <section>
      <h2>LDT over HTTP</h2>
      <section>
        <h3>Concrete syntax</h3>
        <p class="ednote">Link abstract syntax to HTTP ABNF?</p>
      </section>
      <section>
        <h3>Valuation examples</h3>
        <section>
          <h4>GET request</h4>
        </section>
        <section>
          <h4>POST request</h4>
        </section>
        <section>
          <h4>PUT request</h4>
        </section>
        <section>
          <h4>DELETE request</h4>
        </section>
      </section>
    </section>
    <section>
      <h3>Vocabulary</h3>
      <section>
        <h4>Template</h4>
        <pre><strong>ldt:Template</strong>
  rdfs:subClassOf* = rdfs:Class
  <strong>ldt:path = xsd:string</strong>
  <strong>ldt:query = ldt:Query</strong>
  ldt:update? = ldt:Update
  ldt:lang? = rdf:langString
  ldt:cacheControl? = xsd:string
  spin:constructor? = spin:Rule
  rdfs:isDefinedBy = ldt:Ontology</pre>
      </section>
    </section>
  </body>
</html>
