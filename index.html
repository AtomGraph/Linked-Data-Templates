<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <title>Linked Data Templates</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "CG-DRAFT",
        editors: [{
          name: "Martynas Jusevičius",
          mailto: "martynas@atomgraph.com",
          companyURL: "https://atomgraph.com",
        }],
        subtitle: "Generic read-write Linked Data API",
        processVersion: 2017,
        edDraftURI: "https://github.com/AtomGraph/Linked-Data-Templates/tree/gh-pages",
        shortName: "ldt",
        wg: "Declarative Linked Data Apps Community Group",
        wgURI: "https://www.w3.org/community/declarative-apps/",
        wgPublicList: "public-declarative-apps"
      };
    </script>
    <style type="text/css">
       figure img { width: 100%; }
      .abstract-syntax dt , .semantics dt { float: left; }
      .abstract-syntax .internalDFN, .semantics .internalDFN { font-style: italic; }
      .abstract-syntax dt::after { content: "\00a0∈\00a0"; font-weight: normal; }
      .grammar { font-family: monospace; font-size: larger; }
      .domains dt::after, .valuation-functions dt::after { content: "\00a0=\00a0"; font-weight: normal; }
      .functions dt::after { content: "\00a0:\00a0"; font-weight: normal; }
      .functions dd { font-style: italic; }
      table { width: 100%; border: 1px solid black; border-collapse: collapse; }
      table th, table td { border: 1px solid black; padding: 3px; }
      table.core-vocab td:nth-child(2), table.core-vocab td:nth-child(3), table.core-vocab td:nth-child(4), table.core-vocab td:nth-child(6) { font-family: monospace; }
      table.http-vocab td:nth-child(2), table.http-vocab td:nth-child(3), table.http-vocab td:nth-child(4), table.http-vocab td:nth-child(5) { font-family: monospace; }
      var { font-weight: bold; }
    </style>
  </head>
  <body>
    <!-- https://www.w3.org/TR/qaframe-spec/ -->
    <section id="abstract">
      <p>Linked Data Templates (LDT) is a uniform protocol for read-write Linked Data. This document defines an abstract syntax (a data model) of Linked Data applications with SPARQL backends, and semantics of CRUD interactions against their resources. [[LINKED-DATA]][[sparql11-overview]]</p>
      <p>LDT can be used to design ontology-driven Web application programming interfaces (APIs). It provides facilities to define interactions with application resources declaratively using SPARQL commands. It also provides a standard method to evaluate requests into responses over application
        ontology and dataset.</p>
    </section>
    <section id="sotd">
    </section>
    <section id="introduction" class="introductory informative">
      <h2>Introduction</h2>
      <p>Linked Data is a method for publishing structured data, including relationships between data, on the Web using a common data model (RDF). The
      purpose of Linked Data Templates is to provide means to define read-write Linked Data APIs declaratively using SPARQL and specify a uniform
      interaction       protocol for them.</p>
      <p>LDT reconciles ontology-driven Semantic Web, read-write Linked Data and the SPARQL query language. LDT architecture decouples software from
      domain- or application-specific operations, enabling reuse of machine-processable operation descriptions (for composition, reasoning etc.) as
      well as generic implementations of both server and client software. It builds on existing standards; no changes or additions to other specifications
      are required.</p>
      <p>Ontology as a declarative representation of the application's operations, dependency on SPARQL, formal valuation of interactions and the support for HATEOAS hypermedia are the main features that distinguish LDT from other Linked Data specifications such as Linked Data Platform [[LDP]].</p>
      <p>This document defines a precise semantics for SPARQL-backed Linked Data applications, providing a specification of how Append, Read, Update, Delete (CRUD) interactions change the state of their resources. It does so by establishing the following:</p>
      <ul>
        <li>an <a href="#ldt-syntax">abstract syntax</a> of REST and Linked Data</li>
        <li>a <a href="#ldt-domains">formal model</a> of Linked Data applications as well as operations that map interactions to SPARQL commands</li>
        <li>a generic <a href="#ldt-valuation">formal method</a> that evaluates CRUD interactions against application's resources using the operation descriptions</li>
        <li>a <a href="#ldt-http">mapping of LDT to HTTP</a> that translates HTTP interactions into LDT interactions</li>
        <li>an <a href="#vocabulary">RDF vocabulary</a> for encoding operations as RDF ontology terms</li>
      </ul>
      <p>The main LDT concepts are explained below.</p>
      <section>
        <h3>Applications</h3>
        <figure id="architecture">
          <img src="images/components.svg" alt="LDT architecture">
          <figcaption>Main components of LDT architecture</figcaption>
        </figure>
        <p>An LDT application represents a data space identified by its base URI, in which application resource URIs are usually (but not necessarily) relative to the base URI. The only interface an application provides is RESTful Linked Data: application produces RDF representations when resource URIs are
          dereferenced, and consumes RDF representations when requested to change resource state.</p>
      </section>
      <section>
        <h3>Services</h3>
        <p>A service is a datasource from which an LDT application retrieves, and in which it stores RDF data with resource representations. The only interface a service MUST provide is SPARQL 1.1 Protocol [[[sparql11-protocol]]]. That way an application is agnostic to the service implementation
          details: it can be a native RDF triplestore, an RDBMS or XML database with an RDF wrapper, or any other compliant datasource.</p>
      </section>
      <section>
        <h3>Ontologies</h3>
        <p>An ontology is an efficient way to define application structure declaratively as a set of instructions for resource representation processing. LDT application uses a single RDF ontology to define operations specific to that application. Ontologies can be exposed and dereferenced,
          as well as imported and reused by other LDT applications or third-party software.</p>
      </section>
      <section>
        <h3>Operations</h3>
        <p>An operation maps a certain URI pattern to a certain SPARQL command. During request processing, an LDT processor matches request URI against operations and selects the best match (if such exists) that will drive the RDF CRUD processing. Operations are defined using the
          <a href="#vocabulary">LDT vocabulary</a>, while the SPARQL commands are defined using SPIN RDF syntax and use a "magic" variable <var>?this</var> which is bound to the request URI value.</p>
        <p>Processes such as content negotiation, URI resolution, constraint validation etc. are separate from operations and out of scope of this document.</p>
      </section>
      <section>
        <h3>Hypermedia</h3>
        <p>Hypermedia, used here in terms of Hypermedia As The Engine Of Application State (HATEOAS), is the final constraint of REST. It enables loose server/client coupling by requiring the client to navigate by transitioning between server-provided application states. It implies that those
          states need to be URI-identified and provided in response body. LDT addresses this by providing operation parameters that are used to validate and describe requested application states.</p>
      </section>
    </section>
    <section id="conformance">
    </section>
    <section id="ldt-syntax" class="abstract-syntax">
      <h2>Abstract syntax</h2>
      <p>This section defines the data model of LDT applications.</p>
      <section id="rest-syntax">
        <h3>REST</h3>
        <p>In this section we define the abstract syntax REpresentational State Transfer. It sufficient to model a RESTful API independently of the transport protocol.</p>
        <dl>
          <dt><dfn data-lt="token-Request" data-lt-noDefault>Request</dfn></dt>
          <dd>Request</dd>
          <dt><dfn data-lt="token-Response" data-lt-noDefault>Response</dfn></dt>
          <dd>Response</dd>
          <dt><dfn data-lt="token-Body" data-lt-noDefault>Body</dfn></dt>
          <dd>Message-body</dd>
          <dt><dfn data-lt="token-MediaType" data-lt-noDefault>MediaType</dfn></dt>
          <dd>Media-type</dd>
          <dt><dfn data-lt="token-Status" data-lt-noDefault>Status</dfn></dt>
          <dd>Status</dd>
          <dt><dfn data-lt="token-IRI" data-lt-noDefault>IRI</dfn></dt>
          <dd>IRI</dd>
          <dt><dfn data-lt="token-Method" data-lt-noDefault>Method</dfn></dt>
          <dd>Interaction-method</dd>
        </dl>
        <p class="grammar">Request  := Method IRI | Method IRI MediaType Body<br/>
Response := Status MediaType Body</p>
      </section>
      <section id="linked-data-syntax">
        <h3>Linked Data</h3>
        <p>In this section, we specialize the REST abstract syntax by constraining the message body to RDF serializations and read-write interactions to CRUD.</p>
        <dl>
          <dt><dfn data-lt="token-LDRequest" data-lt-noDefault>LDRequest</dfn></dt>
          <dd>RDF-request ⊂ Request</dd>
          <dt><dfn data-lt="token-LDResponse" data-lt-noDefault>LDResponse</dfn></dt>
          <dd>RDF-response ⊂ Response</dd>
          <dt><dfn data-lt="token-RDFMediaType" data-lt-noDefault>RDFMediaType</dfn></dt>
          <dd>RDF-media-type ⊂ Media-type</dd>
          <dt><dfn data-lt="token-Dataset" data-lt-noDefault>Dataset</dfn></dt>
          <dd>Dataset ⊂ Body</dd>
          <dt><dfn data-lt="token-CRUDMethod" data-lt-noDefault>CRUDMethod</dfn></dt>
          <dd>CRUD-method ⊂ Method</dd>
          <dt><dfn data-lt="token-CRUDStatus" data-lt-noDefault>CRUDStatus</dfn></dt>
          <dd>CRUD-status ⊂ Status</dd>
        </dl>
        <p class="grammar">LDRequest  := CRUDMethod IRI | CRUDMethod IRI RDFMediaType Dataset<br/>
LDResponse := CRUDStatus RDFMediaType Dataset<br/>
CRUDMethod  := <code>Append</code> | <code>Read</code> | <code>Delete</code> | <code>Update</code><br/>
CRUDStatus  := <code>NotFound</code> | <code>NoContent</code> | <code>OK</code></p>
      </section>
    </section>
    <section id="ldt-semantics" class="semantics">
      <h2>Semantics</h2>
      <p>We use denotational semantics as the formalism for Linked Data semantics.</p>
      <section id="ldt-domains" class="domains">
        <h3>Domains</h3>
        <dl>
          <dt><dfn data-lt="domain-Method" data-lt-noDefault>Method</dfn></dt>
          <dd><a href="https://www.w3.org/TR/webarch/#interaction">Interaction method</a> [[webarch]]</dd>
          <dt><dfn data-lt="domain-IRI" data-lt-noDefault>IRI</dfn><sub>abs</sub></dt>
          <dd>non-relative <a href="https://www.w3.org/TR/rdf11-concepts/#section-IRIs">IRI identifier</a> [[!rdf11-concepts]]</dd>
          <dt><dfn data-lt="domain-MediaType" data-lt-noDefault>MediaType</dfn></dt>
          <dd>Media Type [[!rfc2046]]</dd>
          <dt><dfn data-lt="domain-Body" data-lt-noDefault>Body</dfn></dt>
          <dd><a href="https://www.w3.org/TR/webarch/#internet-media-type">Representation</a> [[!webarch]]</dd>
          <dt><dfn data-lt="domain-Request" data-lt-noDefault>Request</dfn></dt>
          <dd><a data-lt="domain-Method">Method</a> × <a data-lt="domain-IRI">IRI</a><sub>abs</sub> × <a data-lt="domain-MediaType">MediaType</a> × <a data-lt="domain-Body">Body</a></dd>
          <dt><dfn data-lt="domain-RDFMediaType" data-lt-noDefault>RDFMediaType</dfn></dt>
          <dd>{ <code>text/turtle</code>, <code>text/trig</code>, <code>application/n-triples</code>, <code>application/n-quads</code>, <code>application/ld+json</code>, <code>application/rdf+xml</code>, … } <a href="https://www.w3.org/TR/rdf11-primer/#section-graph-syntax">Writing RDF graphs</a> [[rdf11-primer]]</dd>
          <dt><dfn data-lt="domain-CRUDMethod" data-lt-noDefault>CRUDMethod</dfn></dt>
          <dd>{ <code>Append</code>, <code>Read</code>, <code>Delete</code>, <code>Update</code> }</dd>
          <dt><dfn data-lt="domain-CRUDStatus" data-lt-noDefault>CRUDStatus</dfn></dt>
          <dd>{ <code>NotFound</code>, <code>NoContent</code>, <code>OK</code> }</dd>
          <dt><dfn data-lt="domain-Dataset" data-lt-noDefault>Dataset</dfn></dt>
          <dd><a href="https://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF dataset</a> [[!rdf11-concepts]][[!sparql11-query]]</dd>
          <dt><dfn data-lt="domain-LDRequest" data-lt-noDefault>LDRequest</dfn></dt>
          <dd><a data-lt="domain-CRUDMethod">CRUDMethod</a> × <a data-lt="domain-IRI">IRI</a><sub>abs</sub> × <a data-lt="domain-RDFMediaType">RDFMediaType</a> × <a data-lt="domain-Dataset">Dataset</a></dd>
          <dt><dfn data-lt="domain-LDResponse" data-lt-noDefault>LDResponse</dfn></dt>
          <dd><a data-lt="domain-CRUDStatus">CRUDStatus</a> × <a data-lt="domain-RDFMediaType">RDFMediaType</a> × <a data-lt="domain-Dataset">Dataset</a></dd>
          <dt><dfn data-lt="domain-Ontology" data-lt-noDefault>Ontology</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a>* × <a data-lt="domain-Ontology">Ontology</a>*</dd>
          <dd class="ednote">Denotational semantics do not allow recursive domain definitions such as the one above. This would need to be reworked to be strictly formal.</dd>
          <!--
          <dt><dfn>Service</a></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-service-description/#terminology">SPARQL Service</a> [[!sparql11-service-description]]</dd>
          -->
          <dt><dfn data-lt="domain-App" data-lt-noDefault>App</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> × <a data-lt="domain-Ontology">Ontology</a> × <a data-lt="domain-Dataset">Dataset</a></dd>
          <dd class="ednote">Here we define an ontology with a <a data-lt="domain-Dataset">Dataset</a>, yet the implementation/vocabulary uses a Service which is an interface for the Dataset.</dd>
          <dt><dfn data-lt="domain-QueryVariable" data-lt-noDefault>QueryVariable</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#sparqlQueryVariables">Query Variable</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="domain-RDFTerm" data-lt-noDefault>RDFTerm</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#sparqlBasicTerms">RDF Term</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="domain-QueryBinding" data-lt-noDefault>QueryBinding</dfn></dt>
          <dd><a data-lt="domain-QueryVariable">QueryVariable</a> × <a data-lt="domain-RDFTerm">RDFTerm</a></dd>
          <dt><dfn data-lt="domain-Describe" data-lt-noDefault>Describe</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#describe">DESCRIBE</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="domain-Construct" data-lt-noDefault>Construct</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#construct">CONSTRUCT</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="domain-Query" data-lt-noDefault>Query</dfn></dt>
          <dd><a data-lt="domain-Describe">Describe</a> + <a data-lt="domain-Construct">Construct</a></dd>
          <dt data-lt="domain-Delete" data-lt-noDefault><dfn>Delete</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-update/#delete">DELETE</a> [[!sparql11-update]]</dd>
          <dt><dfn data-lt="domain-Command" data-lt-noDefault>Command</dfn></dt>
          <dd><a data-lt="domain-Query">Query</a> + <a data-lt="domain-Delete">Delete</a></dd>
          <dt data-lt="domain-IRIPattern" data-lt-noDefault><dfn>IRIPattern</dfn></dt>
          <dd><a href="http://download.oracle.com/otn-pub/jcp/jaxrs-1.0-fr-eval-oth-JSpec/jaxrs-1.0-final-spec.pdf#page=21">URI template</a> [[!JAX-RS]]</dd>
          <dt><dfn data-lt="domain-Parameter" data-lt-noDefault>Parameter</dfn></dt>
          <dd>String × <a data-lt="domain-IRI">IRI</a> × Boolean</dd>
          <dt><dfn data-lt="domain-Operation" data-lt-noDefault>Operation</dfn></dt>
          <dd><a data-lt="domain-IRIPattern">IRIPattern</a> × <a data-lt="domain-Query">Query</a> × <a data-lt="domain-Delete">Delete</a> × <a data-lt="domain-Parameter">Parameter</a>*</dd>
          <dt><dfn data-lt="domain-OperationPrecedence" data-lt-noDefault>OperationPrecedence</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a> × Integer</dd>
          <dt><dfn data-lt="domain-Argument" data-lt-noDefault>Argument</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a> × <a data-lt="domain-RDFTerm">RDFTerm</a></dd>
      </dl>
      </section>
      <section id="ldt-functions" class="functions">
        <h3>Functions</h3>
        <dl>
          <dt><dfn data-lt="func-absolutePath" data-lt-noDefault>absolutePath</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> → <a data-lt="domain-IRI">IRI</a><sub>abs</sub></dd>
          <dd>absolutePath(iri) = <a href="https://www.w3.org/TR/xpath-functions-3/#func-substring-before">fn:substring-before</a>(absoluteIri, "<code>?</code>") = absolutePath ∈ <a data-lt="domain-IRI">IRI</a><sub>abs</sub> [[!xpath-functions-31]]</dd>
          <dt><dfn data-lt="func-queryString" data-lt-noDefault>queryString</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> → String</dd>
          <dd>queryString(iri) = <a href="https://www.w3.org/TR/xpath-functions-3/#func-substring-after">fn:substring-after</a>(absoluteIri, "<code>?</code>") = queryString ∈ String [[!xpath-functions-31]]</dd>
          <dt><dfn data-lt="func-method" data-lt-noDefault>method</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a>↓1 → <a data-lt="domain-Method">Method</a>
          <dt><dfn data-lt="func-iri" data-lt-noDefault>iri</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a>↓2 → <a data-lt="domain-IRI">IRI</a></dd>
          <dt><dfn>mediaType</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a>↓3 → <a data-lt="domain-MediaType">MediaType</a> + { <code>NoType</code> }</dd>
          <dt><dfn>body</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a>↓4 → <a data-lt="domain-Body">Body</a></dd>
          <dt><dfn data-lt="func-operations" data-lt-noDefault>operations</dfn></dt>
          <dd><a data-lt="domain-Ontology">Ontology</a>↓1 → <a data-lt="domain-Operation">Operation</a>*</dd>
          <dt><dfn data-lt="func-imports" data-lt-noDefault>imports</dfn></dt>
          <dd><a data-lt="domain-Ontology">Ontology</a>↓2 → <a data-lt="domain-Ontology">Ontology</a>*</dd>
          <dt><dfn data-lt="func-base" data-lt-noDefault>base</dfn></dt>
          <dd><a data-lt="domain-App">App</a>↓1 → <a data-lt="domain-IRI">IRI</a>
          <dt><dfn data-lt="func-ontology" data-lt-noDefault>ontology</dfn></dt>
          <dd><a data-lt="domain-App">App</a>↓2 → <a data-lt="domain-Ontology">Ontology</a>
          <dt><dfn data-lt="func-dataset" data-lt-noDefault>dataset</dfn></dt>
          <dd><a data-lt="domain-App">App</a>↓3 → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dt><dfn data-lt="func-relativize" data-lt-noDefault>relativize</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> × <a data-lt="domain-IRI">IRI</a> → <dfn>IRI<sub>rel</sub></dfn> ⊂ <a data-lt="domain-IRI">IRI</a></dd>
          <dd>relativize(absoluteIri1, absoluteIri2) = relativeIri</dd>
          <dd>The processor MUST implement <a data-lt="func-relativize">relativize</a> as defined in <a href="https://tools.ietf.org/html/rfc3986#section-5.2">Relative Resolution</a> [[!rfc3986]].</dd>
          <dt><dfn data-lt="func-app" data-lt-noDefault>app</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> → <a data-lt="domain-App">App</a></dd>
          <dd>app(iri) = appminPath ∈ App such that<br/>
            <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a data-lt="func-relativize">relativize</a>(<a data-lt="func-base">base</a>(appminPath), iri)) &#8804; <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a data-lt="func-relativize">relativize</a>(<a data-lt="func-base">base</a>(app), iri))<br/>
          for all app ∈ <a data-lt="domain-App">App</a> : app ≠ appminPath [[xpath-functions-31]]</dd>
          <dt><dfn data-lt="func-apply" data-lt-noDefault>apply</dfn></dt>
          <dd><a data-lt="domain-Command">Command</a> × <a data-lt="domain-QueryBinding">QueryBinding</a>* → <a data-lt="domain-Command">Command</a></dd>
          <dt><dfn data-lt="func-execQuery" data-lt-noDefault>execQuery</dfn></dt>
          <dd><a data-lt="domain-Query">Query</a> × <a data-lt="domain-Dataset">Dataset</a> → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dt><dfn data-lt="func-execDelete" data-lt-noDefault>execDelete</dfn></dt>
          <dd><a data-lt="domain-Delete">Delete</a> × <a data-lt="domain-Dataset">Dataset</a> → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dt><dfn data-lt="func-empty" data-lt-noDefault>empty</dfn></dt>
          <dd><a data-lt="domain-Dataset">Dataset</a></dd>
          <dd>Empty RDF dataset [[!sparql11-update]]</dd>
          <dt><dfn data-lt="func-name" data-lt-noDefault>name</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a>↓1 → String</dd>
          <dt><dfn data-lt="func-valueType" data-lt-noDefault>valueType</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a>↓2 → <a data-lt="domain-IRI">IRI</a></dd>
          <dt><dfn data-lt="func-optional" data-lt-noDefault>optional</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a>↓3 → Boolean</dd>
          <dt><dfn data-lt="func-iriPattern" data-lt-noDefault>iriPattern</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a>↓1 → <a data-lt="domain-IRIPattern">IRIPattern</a></dd>
          <dt><dfn data-lt="func-query" data-lt-noDefault>query</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a>↓2 → <a data-lt="domain-Query">Query</a></dd>
          <dt><dfn data-lt="func-delete" data-lt-noDefault>delete</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a>↓3 → <a data-lt="domain-Delete">Delete</a></dd>
          <dt><dfn data-lt="func-parameters" data-lt-noDefault>parameters</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a>↓4 → <a data-lt="domain-Parameter">Parameter</a>*</dd>
          <dt><dfn data-lt="func-noMatch" data-lt-noDefault>noMatch</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a></dd>
          <dt><dfn data-lt="func-matchPattern" data-lt-noDefault>matchPattern</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a><sub>rel</sub> × <a data-lt="domain-IRIPattern">IRIPattern</a> → Boolean</dd>
          <dd>The processor MUST implement <a data-lt="func-matchPattern">matchPattern</a> as defined in <a href="http://download.oracle.com/otn-pub/jcp/jaxrs-2_0-fr-eval-spec/jsr339-jaxrs-2.0-final-spec.pdf#page=32">Request Matching</a>, using C = <a data-lt="domain-Ontology">Ontology</a>, T<sub>Z</sub> = <a data-lt="func-iriPattern">iriPattern</a>(operation) [[!JAX-RS]]</dd>
          <dt><dfn data-lt="func-precedence" data-lt-noDefault>precedence</dfn></dt>
          <dd><a data-lt="domain-Operation">Operation</a> × Integer → <a data-lt="domain-OperationPrecedence">OperationPrecedence</a></dd>
          <dd>precedence(operation, precedence) = (operation, precedence)</dd>
          <dt><dfn data-lt="func-matchOperations" data-lt-noDefault>matchOperations</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a><sub>rel</sub> × <a data-lt="domain-Operation">Operation</a>* × Integer → <a data-lt="domain-OperationPrecedence">OperationPrecedence</a>*</dd>
          <dd>matchOperations(iri<sub>rel</sub>, operations, precedence) = cons(null(operations) → nil [] <a data-lt="func-matchPattern">matchPattern</a>(<a data-lt="func-iriPattern">iriPattern</a>(head(operations))) → <a data-lt="func-precedence">precedence</a>(head(operations), precedence * -1) [] nil, <a data-lt="func-matchOperations">matchOperations</a>(tail(operations), precedence))</dd>
          <dd class="ednote">Denotational semantics do not allow recursive function definitions as the one above. This would need to be reworked to be strictly formal.</dd>
          <dt><dfn data-lt="func-matchPrecedences" data-lt-noDefault>matchPrecedences</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a><sub>rel</sub> × <a data-lt="domain-Ontology">Ontology</a> × Integer → <a data-lt="domain-OperationPrecedence">OperationPrecedence</a>*</dd>
          <dd>matchPrecedences(iri<sub>rel</sub>, ontology, importLevel) = cons(<a data-lt="func-matchOperations">matchOperations</a>(iri<sub>rel</sub>, <a data-lt="func-operations">operations</a>(ontology)), null(<a data-lt="func-imports">imports</a>(ontology)) → nil [] <a data-lt="func-matchPrecedences">matchPrecedences</a>(iri<sub>rel</sub>, head(<a data-lt="func-imports">imports</a>(ontology)), importLevel + 1))</dd>
          <dd class="ednote">Denotational semantics do not allow recursive function definitions as the one above. This would need to be reworked to be strictly formal.</dd>
          <dt><dfn data-lt="func-topMatch" data-lt-noDefault>topMatch</dfn></dt>
          <dd><a data-lt="domain-OperationPrecedence">OperationPrecedence</a>* → <a data-lt="domain-Operation">Operation</a> + { <code>NoMatch</code> }</dd>
          <dd>topMatch(opPrecedences) = null(opPrecedences) → <code>NoMatch</code> [] topMatch((operation<sub>1</sub>, precedence<sub>1</sub>), …, (operation<sub>i</sub>, precedence<sub>i</sub>), …, (operation<sub>n</sub>, precedence<sub>n</sub>)) = operation<sub>i</sub> : precedence<sub>i</sub> &#8805; precedence<sub>j</sub> for all i, j</dd>
          <dt><dfn data-lt="func-match" data-lt-noDefault>match</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a><sub>rel</sub> × <a data-lt="domain-Ontology">Ontology</a> → <a data-lt="domain-Operation">Operation</a> + { <code>NoMatch</code> }</dd>
          <dd>match(iri<sub>rel</sub>, ontology) = <a data-lt="func-topMatch">topMatch</a>(<a data-lt="func-matchPrecedences">matchPrecedences</a>(iri<sub>rel</sub>, ontology, 0))</dd>
          <dt><dfn data-lt="func-reqMatch" data-lt-noDefault>reqMatch</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a> × <a data-lt="domain-App">App</a> → <a data-lt="domain-Operation">Operation</a> + { <code>NoMatch</code> }</dd>
          <dd>reqMatch(request, app) = <a data-lt="func-match">match</a>(<a data-lt="func-relativize">relativize</a>(<a data-lt="func-base">base</a>(app), <a data-lt="func-absolutePath">absolutePath</a>(<a data-lt="func-iri">iri</a>(request))))</dd>
          <dt><dfn data-lt="func-decodeUri" data-lt-noDefault>decodeUri</dfn></dt>
          <dd>String → String</dd>
          <dd>decodeUri(encoded) = decoded such that <a href="https://www.w3.org/TR/xpath-functions-31/#func-encode-for-uri">fn:encode-for-uri(decoded)</a> = encoded [[xpath-functions-31]]</dd>
          <dt><dfn data-lt="func-cast" data-lt-noDefault>cast</dfn></dt>
          <dd><a data-lt="domain-RDFTerm">RDFTerm</a> × <a data-lt="domain-IRI">IRI</a> → <a data-lt="domain-RDFTerm">RDFTerm</a></dd>
          <dd>cast(inputValue, targetType) = targetValue ∈ RDFTerm</dd>
          <dd>The processor MUST implement <a data-lt="func-cast">cast</a> as defined in <a href="https://www.w3.org/TR/sparql11-query/#FunctionMapping">XPath Constructor Functions</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="func-tokenize" data-lt-noDefault>tokenize</dfn></dt>
          <dd>String → String*</dd>
          <dd>tokenize(string, delimiter) = <a href="https://www.w3.org/TR/xpath-functions/#func-tokenize">fn:tokenize</a>(string, delimiter)</dd>
          <dt><dfn data-lt="func-argumentPairs" data-lt-noDefault>argumentPairs</dfn></dt>
          <dd>String* → (String × String)*</dd>
          <dd>argumentPairs(strings) = cons(null(strings) → nil [] (<a data-lt="func-decodeUri">decodeUri</a>(head(<a data-lt="func-tokenize">tokenize</a>(head(strings), "<code>=</code>"))), <a data-lt="func-decodeUri">decodeUri</a>(head(tail(<a data-lt="func-tokenize">tokenize</a>(head(strings), "<code>=</code>"))))), <a data-lt="func-argumentPairs">argumentPairs</a>(tail(strings)))</dd>
          <dd class="ednote">Denotational semantics do not allow recursive function definitions as the one above. This would need to be reworked to be strictly formal.</dd>
          <dt><dfn data-lt="func-argPairsByName" data-lt-noDefault>argPairsByName</dfn></dt>
          <dd>(String × String)* × String → (String × String)*</dd>
          <dd>argPairsByName(argumentPairs, name) = cons(null(argumentPairs) → nil [] head(argumentPairs)↓1 = name → head(argumentPairs) [] nil, <a data-lt="func-argPairsByName">argPairsByName</a>(tail(argumentPairs), name))</dd>
          <dd class="ednote">Denotational semantics do not allow recursive function definitions as the one above. This would need to be reworked to be strictly formal.</dd>
          <dt><dfn data-lt="func-paramArgs" data-lt-noDefault>paramArgs</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a> × (String × String)* → <a data-lt="domain-Argument">Argument</a>*</dd>
          <dd>paramArgs(parameter, argumentPairs) = null(argumentPairs) → nil [] cons((parameter, <a data-lt="func-cast">cast</a>(head(<a data-lt="func-argPairsByName">argPairsByName</a>(argumentPairs, name(parameter)))↓2, <a data-lt="func-valueType">valueType</a>(parameter))), <a data-lt="func-paramArgs">paramArgs</a>(parameter, tail(argumentPairs)))</dd>
          <dt><dfn data-lt="func-paramListArgs" data-lt-noDefault>paramListArgs</dfn></dt>
          <dd><a data-lt="domain-Parameter">Parameter</a>* × (String × String)* → <a data-lt="domain-Argument">Argument</a>*</dd>
          <dd>paramListArgs(parameters, argumentPairs) = null(parameters) → nil [] concat(<a data-lt="func-paramArgs">paramArgs</a>(head(parameters), argumentPairs), <a data-lt="func-paramListArgs">paramListArgs</a>(tail(parameters), argumentPairs))</dd>
          <dd class="ednote">Denotational semantics do not allow recursive function definitions as the one above. This would need to be reworked to be strictly formal.</dd>
          <dt><dfn data-lt="func-parameter" data-lt-noDefault>parameter</dfn></dt>
          <dd><a data-lt="domain-Argument">Argument</a>↓1 → <a data-lt="domain-Parameter">Parameter</a></dd>
          <dt><dfn data-lt="func-value" data-lt-noDefault>value</dfn></dt>
          <dd><a data-lt="domain-Argument">Argument</a>↓2 → <a data-lt="domain-RDFTerm">RDFTerm</a></dd>
          <dt><dfn data-lt="func-conNeg" data-lt-noDefault>conNeg</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a> → <a data-lt="domain-MediaType">MediaType</a></dd>
          <dd>The processor MUST implement <a data-lt="func-conNeg">conNeg</a> as defined in <a href="http://download.oracle.com/otn-pub/jcp/jaxrs-1.0-fr-eval-oth-JSpec/jaxrs-1.0-final-spec.pdf#page=28">Determining the MediaType of Responses</a> [[!JAX-RS]]</dd>
          <dt><dfn data-lt="func-variable" data-lt-noDefault>variable</dfn></dt>
          <dd>String → <a data-lt="domain-QueryVariable">QueryVariable</a></dd>
          <dt><dfn data-lt="func-argBindings" data-lt-noDefault>argBindings</dfn></dt>
          <dd> <a data-lt="domain-Argument">Argument</a>* → <a data-lt="domain-QueryBinding">QueryBinding</a>*</dd>
          <dd>argBindings(arguments) = cons(null(arguments) → nil [] (<a data-lt="func-variable">variable</a>(<a data-lt="func-name">name</a>(<a data-lt="func-parameter">parameter</a>(head(arguments)))), <a data-lt="func-value">value</a>(head(arguments))), <a data-lt="func-argBindings">argBindings</a>(arguments))</dd>
          <dt><dfn data-lt="func-merge" data-lt-noDefault>merge</dfn></dt>
          <dd><a data-lt="domain-Dataset">Dataset</a> × <a data-lt="domain-Dataset">Dataset</a> → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dd>merge(dataset<sub>1</sub>, dataset<sub>2</sub>) = dataset ∈ Dataset</dd>
          <dd>The processor MUST implement <a data-lt="func-merge">merge</a> as defined in <a href="https://www.w3.org/TR/sparql11-query/#sparqlDataset">RDF Dataset</a> [[!sparql11-query]]</dd>
          <dt><dfn data-lt="func-state" data-lt-noDefault>state</dfn></dt>
          <dd><a data-lt="domain-IRI">IRI</a> × <a data-lt="domain-Argument">Argument</a>* → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dd class="ednote">This is the function that should describe the current application state. How do we convert from sets to triples? Parameters need to have IRIs.</dd>
          <dt><dfn data-lt="func-readData" data-lt-noDefault>readData</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a> × <a data-lt="domain-App">App</a> → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dd>readData(request, app) = <a data-lt="func-execQuery">execQuery</a>(<a data-lt="func-apply">apply</a>(<a data-lt="func-query">query</a>(<a data-lt="func-reqMatch">reqMatch</a>(request, app)), cons((<a data-lt="func-variable">variable</a>(<var>this</var>), <a data-lt="func-absolutePath">absolutePath</a>(<a data-lt="func-iri">iri</a>(request))), <a data-lt="func-argBindings">argBindings</a>(<a data-lt="func-paramListArgs">paramListArgs</a>(<a data-lt="func-parameters">parameters</a>(<a data-lt="func-reqMatch">reqMatch</a>(request, app)), <a data-lt="func-argumentPairs">argumentPairs</a>(<a data-lt="func-tokenize">tokenize</a>(<a data-lt="func-queryString">queryString</a>(<a data-lt="func-iri">iri</a>(request)))))))), <a data-lt="func-dataset">dataset</a>(app))</dd>
          <dt><dfn data-lt="func-deleteData" data-lt-noDefault>deleteData</dfn></dt>
          <dd><a data-lt="domain-Request">Request</a> × <a data-lt="domain-App">App</a> → <a data-lt="domain-Dataset">Dataset</a></dd>
          <dd>deleteData(request, app) = <a data-lt="func-execDelete">execDelete</a>(<a data-lt="func-apply">apply</a>(<a data-lt="func-delete">delete</a>(<a data-lt="func-reqMatch">reqMatch</a>(request, app)), cons((<a data-lt="func-variable">variable</a>(<var>this</var>), <a data-lt="func-absolutePath">absolutePath</a>(<a data-lt="func-iri">iri</a>(request))), <a data-lt="func-argBindings">argBindings</a>(<a data-lt="func-paramListArgs">paramListArgs</a>(<a data-lt="func-parameters">parameters</a>(<a data-lt="func-reqMatch">reqMatch</a>(request, app)), <a data-lt="func-argumentPairs">argumentPairs</a>(<a data-lt="func-tokenize">tokenize</a>(<a data-lt="func-queryString">queryString</a>(<a data-lt="func-iri">iri</a>(request)))))))), <a data-lt="func-dataset">dataset</a>(app))</dd>
        </dl>
      </section>
      <section id="ldt-valuation" class="valuation-functions">
        <h3>Valuation functions</h3>
        <p>Evaluation of response to request ∈ <a data-lt="domain-LDRequest">LDRequest</a>:</p>
        <p>
          <dfn>LDResponse</dfn> : <a data-lt="domain-LDRequest">LDRequest</a> → <a data-lt="domain-LDResponse">LDResponse</a> × <a data-lt="domain-Dataset">Dataset</a>
        </p>
        <dl>
          <dt><a data-lt="domain-LDResponse">LDResponse</a> [[<a data-lt="token-CRUDStatus">CRUDStatus</a> <a data-lt="token-RDFMediaType">RDFMediaType</a> <a data-lt="token-Dataset">Dataset</a>]] (request)</dt>
          <dd><a data-lt="domain-LDResponse">LDResponse</a> [[<a data-lt="token-CRUDStatus">CRUDStatus</a> <a data-lt="token-RDFMediaType">RDFMediaType</a> <a data-lt="token-Dataset">Dataset</a>]] (<a data-lt="func-app">app</a>(<a data-lt="func-iri">iri</a>(request))) (request)</dd>
          <dt><a data-lt="domain-LDResponse">LDResponse</a> [[<a data-lt="token-CRUDStatus">CRUDStatus</a> <a data-lt="token-RDFMediaType">RDFMediaType</a> <a data-lt="token-Dataset">Dataset</a>]] (app) (request)</dt>
          <dd>((<a data-lt="func-reqMatch">reqMatch</a>(request, app) = <code>NoMatch</code> → <code>NotFound</code> []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Delete</code> → <code>NoContent</code> []<br/>
            <code>OK</code>,<br/>
            <a data-lt="func-conNeg">conNeg</a>(request),<br/>
            <a data-lt="func-method">method</a>(request) = <code>Read</code> → <a data-lt="func-merge">merge</a>(<a data-lt="func-readData">readData</a>(request, app), <a data-lt="func-state">state</a>(<a data-lt="func-iri">iri</a>(request), <a data-lt="func-paramListArgs">paramListArgs</a>(<a data-lt="func-parameters">parameters</a>(<a data-lt="func-reqMatch">reqMatch</a>(request, app)), <a data-lt="func-argumentPairs">argumentPairs</a>(<a data-lt="func-tokenize">tokenize</a>(<a data-lt="func-queryString">queryString</a>(<a data-lt="func-iri">iri</a>(request))))))) []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Append</code> → <a data-lt="func-empty">empty</a> []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Update</code> → <a data-lt="func-empty">empty</a> []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Delete</code> → <a data-lt="func-empty">empty</a>),<br/>

            <a data-lt="func-method">method</a>(request) = <code>Read</code> → <a data-lt="func-dataset">dataset</a>(app) []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Append</code> → <a data-lt="func-merge">merge</a>(<a data-lt="func-body">body</a>(request), <a data-lt="func-dataset">dataset</a>(app)) []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Update</code> → <a data-lt="func-merge">merge</a>(<a data-lt="func-body">body</a>(request), <a data-lt="func-deleteData">deleteData</a>(request, app)) []<br/>
            <a data-lt="func-method">method</a>(request) = <code>Delete</code> → <a data-lt="func-deleteData">deleteData</a>(request, app))</dd>
        </dl>
      </section>
    </section>
    <section id="ldt-http">
      <h2>LDT over HTTP</h2>
      <section id="http-syntax" class="abstract-syntax">
        <h3>Abstract syntax</h3>
        <dl>
          <dt><dfn data-lt="token-HTTPRequest" data-lt-noDefault>HTTPRequest</dfn></dt>
          <dd>HTTP-request ⊂ Request</dd>
          <dt><dfn data-lt="token-HTTPResponse" data-lt-noDefault>HTTPResponse</dfn></dt>
          <dd>HTTP-response ⊂ Response</dd>
          <dt><dfn data-lt="token-HTTPStatus" data-lt-noDefault>HTTPStatus</dfn></dt>
          <dd>HTTP-status ⊂ Status</dd>
          <dt><dfn data-lt="token-HTTPMethod" data-lt-noDefault>HTTPMethod</dfn></dt>
          <dd>HTTP-method ⊂ Method</dd>
        </dl>
        <p class="grammar">HTTPRequest  := HTTPMethod IRI | HTTPMethod IRI MediaType Body<br/>
HTTPResponse := HTTPStatus MediaType Body<br/>
HTTPMethod := <code>GET</code> | <code>POST</code> | <code>PUT</code> | <code>DELETE</code><br/>
HTTPStatus := <code>200 OK</code> | <code>204 No Content</code> | <code>404 Not Found</code><br/>
</p>
      </section>
      <section id="http-semantics" class="semantics">
        <h3>Semantics</h3>
        <section id="http-domains" class="domains">
          <h4>Domains</h4>
          <dl>
            <dt><dfn data-lt="domain-HTTPRequest" data-lt-noDefault>HTTPRequest</dfn></dt>
            <dd><a data-lt="domain-HTTPMethod">HTTPMethod</a> × <a data-lt="domain-IRI">IRI</a><sub>abs</sub> × <a data-lt="domain-Body">Body</a></dd>
            <dt><dfn data-lt="domain-HTTPResponse" data-lt-noDefault>HTTPResponse</dfn></dt>
            <dd><a data-lt="domain-HTTPStatus">HTTPStatus</a> × <a data-lt="domain-MediaType">MediaType</a> × <a data-lt="domain-Body">Body</a></dd>
            <dt><dfn data-lt="domain-HTTPMethod" data-lt-noDefault>HTTPMethod</dfn></dt>
            <dd>{ <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> } ⊂ <a href="https://tools.ietf.org/html/rfc7231#section-4">Request Methods</a> [[!HTTP11]]</dd>
            <dt><dfn data-lt="domain-HTTPStatus" data-lt-noDefault>HTTPStatus</dfn></dt>
            <dd>{ <code>200 OK</code>, <code>204 No Content</code>, <code>404 Not Found</code> } ⊂ <a href="https://tools.ietf.org/html/rfc7231#section-6">Response Status Codes</a> [[!HTTP11]]</dd>
          </dl>
        </section>
        <section id="http-functions" class="functions">
          <h4>Functions</h4>
          <dl>
            <dt><dfn>httpMethodToCRUDMethodMapping</dfn></dt>
            <dd>(<a data-lt="domain-CRUDMethod">CRUDMethod</a> × <a data-lt="domain-HTTPMethod">HTTPMethod</a>)*</dd>
            <dd>((<code>POST</code>, <code>Append</code>), (<code>GET</code>, <code>Read</code>), (<code>PUT</code>, <code>Update</code>), (<code>DELETE</code>, <code>Delete</code>))</dd>
            <dt><dfn>crudStatusToHTTPStatusMapping</dfn></dt>
            <dd>(<a data-lt="domain-CRUDStatus">CRUDStatus</a> × <a data-lt="domain-HTTPStatus">HTTPStatus</a>)*</dd>
            <dd>((<code>NotFound</code>, <code>404 Not Found</code>), (<code>NoContent</code>, <code>204 No Content</code>), (<code>OK</code>, <code>200 OK</code>))</dd>
            <dt><dfn>httpMethodToCRUDMethod</dfn></dt>
            <dd><a data-lt="domain-HTTPMethod">HTTPMethod</a> × (<a data-lt="domain-CRUDMethod">CRUDMethod</a> × <a data-lt="domain-HTTPMethod">HTTPMethod</a>)* → <a data-lt="domain-CRUDMethod">CRUDMethod</a></dd>
            <dd>httpMethodToCRUDMethod(httpMethod, methodMapping) = head(methodMapping)↓2 = httpMethod → head(methodMapping)↓1 [] httpMethodToCRUDMethod(httpMethod, tail(methodMapping))</dd>
            <dd class="ednote">Denotational semantics do not allow recursive domain definitions such as the one above. This would need to be reworked to be strictly formal.</dd>
            <dt><dfn>crudStatusToHTTPStatus</dfn></dt>
            <dd><a data-lt="domain-CRUDStatus">CRUDStatus</a> × (<a data-lt="domain-CRUDStatus">CRUDStatus</a> × <a data-lt="domain-HTTPStatus">HTTPStatus</a>)* → <a data-lt="domain-HTTPStatus">HTTPStatus</a></dd>
            <dd>crudStatusToHTTPStatus(crudStatus, statusMapping) = head(statusMapping)↓1 = crudStatus → head(statusMapping)↓2 [] crudStatusToHTTPStatus(crudStatus, tail(statusMapping))</dd>
            <dd class="ednote">Denotational semantics do not allow recursive domain definitions such as the one above. This would need to be reworked to be strictly formal.</dd>
          </dl>
        </section>
        <section id="http-valuation" class="valuation-functions">
          <h3>Valuation functions</h3>
          <p>Evaluation of response to request ∈ <a data-lt="domain-HTTPRequest">HTTPRequest</a>:</p>
          <p>
            <dfn>HTTPResponse</dfn> : <a data-lt="domain-HTTPRequest">HTTPRequest</a> → <a data-lt="domain-HTTPResponse">HTTPResponse</a> × <a data-lt="domain-Dataset">Dataset</a>
          </p>
          <dl>
            <dt><a data-lt="domain-HTTPResponse">HTTPResponse</a> [[<a data-lt="token-HTTPStatus">HTTPStatus</a> <a data-lt="domain-MediaType">MediaType</a> <a data-lt="domain-Body">Body</a>]] (httpRequest)</dt>
            <dd>(<a data-lt="func-crudStatusToHTTPStatus">crudStatusToHTTPStatus</a>(ldResponse↓1, <a data-lt="func-crudStatusToHTTPStatusMapping">crudStatusToHTTPStatusMapping</a>), ldResponse↓2, ldResponse↓3) : ldResponse = (<a data-lt="domain-LDResponse">LDResponse</a> [[<a data-lt="token-CRUDStatus">CRUDStatus</a> <a data-lt="token-RDFMediaType">RDFMediaType</a> <a data-lt="token-Dataset">Dataset</a>]] ((<a data-lt="func-httpMethodToCRUDMethod">httpMethodToCRUDMethod</a>(<a data-lt="func-method">method</a>(httpRequest), <a data-lt="func-httpMethodToCRUDMethodMapping">httpMethodToCRUDMethodMapping</a>), <a data-lt="func-iri">iri</a>(httpRequest), <a data-lt="func-mediaType">mediaType</a>(httpRequest), <a data-lt="func-body">body</a>(httpRequest))))</dd>
          </dl>
        </section>
      </section>
    </section>
    <section id="examples" class="informative">
      <h3>Examples</h3>
      <p>We will use the following set members for all the subsequent response valuation examples:</p>
      <dl class="domains">
        <dt><code>app</code> ∈ <a data-lt="domain-App">App</a></dt>
        <dd><a data-lt="func-app">app</a>(<a data-lt="func-iri">iri</a>(request)) = (<code>&lt;https://linkeddatahub.com/&gt;</code>, <code>ontology</code>, <code>dataset</code>)</dd>
        <dt><code>graphParam</code> ∈ <a data-lt="domain-Parameter">Parameter</a></dt>
        <dd>(<code>"g"</code>, <code>&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;</code>, <code>true</code>)</dd>
        <dt><code>match</code> ∈ <a data-lt="domain-Operation">Operation</a></dt>
        <dd><a data-lt="func-reqMatch">reqMatch</a>(request, app) = (<code>"/people/{familyName}"</code>, <code>describeWithTopic</code>, <code>deleteWithTopic</code>, (<code>graphParam</code>))</dd>
        <dt><code>describeWithTopic</code> ∈ <a data-lt="domain-Describe">Describe</a></dt>
        <dd><pre><code>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }</code></pre></dd>
        <dt><code>deleteWithTopic</code> ∈ <a data-lt="domain-Delete">Delete</a></dt>
        <dd><pre><code>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }</code></pre></dd>
      </dl>
      <section id="ontology-example">
        <h4>Ontology</h4>
        <p>The following example shows the ontology of our example application. Operations used in response valuation are encoded as RDF terms using LDT <a href="#vocabulary">vocabulary</a> and SPIN vocabulary:</p>
        <div class="example">
          <pre>@prefix :     &lt;https://linkeddatahub.com/ns#&gt; .
@prefix ldt:  &lt;https://www.w3.org/ns/ldt#&gt; .
@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix sp:   &lt;http://spinrdf.org/sp#&gt; .
@prefix spl:  &lt;http://spinrdf.org/spl#&gt; .

: a ldt:Ontology ;
  owl:imports ldt:, sp: ;
  rdfs:label "Example ontology" .

:PersonItem a ldt:Template ;
  rdfs:label "Person item" ;
  ldt:match "/people/{familyName}" ;
  ldt:param :GraphParam ;
  ldt:query :DescribeWithTopic ;
  ldt:update :DeleteWithTopic ;
  rdfs:isDefinedBy : .

:GraphParam a ldt:Parameter ;
  rdfs:label "Graph parameter" ;
  spl:predicate :g ;
  spl:valueType rdfs:Resource ;
  spl:optional true ;
  rdfs:isDefinedBy : .

:DescribeWithTopic a ldt:Query, sp:Describe ;
  rdfs:label "Describe with topic" ;
  sp:text """PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }""" ;
  rdfs:isDefinedBy : .

:DeleteWithTopic a ldt:Update, sp:Modify ;
  rdfs:label "Delete with topic" ;
  sp:text """PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }""" ;
  rdfs:isDefinedBy : .</pre>
        </div>
      </section>
      <section id="put-example">
        <h4>Update over HTTP</h4>
        <p>The following example shows how an HTTP <code>PUT</code> request with an RDF dataset as its body evaluates as Linked Data <code>Update</code> request on an LDT application. The evaluation result is a successful HTTP response and operations on the application's dataset.</p>
        <p>SPARQL update execution removes the existing description of the requested resource in the dataset. It is followed by a merge of the request body into the dataset. The updated application dataset is a side-effect of the interaction.</p>
        <div class="example">
          <p>HTTP PUT request <code>putRequest</code> with request body <code>putBody</code></p>
          <pre>PUT /people/Berners-Lee HTTP/1.1
Host: linkeddatahub.com
Accept: text/turtle, text/trig
Content-Type: text/trig

@base         &lt;https://linkeddatahub.com/people/Berners-Lee&gt; .
@prefix c:    &lt;https://www.w3.org/ns/ldt/core/domain#&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt; .

&lt;../graphs/c5f34fe9-0456-48e8-a371-04be71529762&gt;
{

  &lt;&gt; a c:Document ;
    foaf:primaryTopic &lt;#this&gt; .

  &lt;#this&gt; a foaf:Person ;
    foaf:isPrimaryTopicOf &lt;&gt; ;
    owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .

}</pre>
        </div>
        <div class="example">
          <p>Valuation of <code>putRequest</code></p>
          <pre>HTTPResponse [[HTTPStatus MediaType Body]] (putRequest) =

(crudStatusToHTTPStatus(ldResponse↓1, crudStatusToHTTPStatusMapping), ldResponse↓2, ldResponse↓3) : ldResponse = (LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(method(putRequest), httpMethodToCRUDMethodMapping), iri(putRequest), mediaType(putRequest), body(putRequest))))↓1

ldResponse = (LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(method(putRequest), httpMethodToCRUDMethodMapping), iri(putRequest), mediaType(putRequest), body(putRequest))))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(PUT, httpMethodToCRUDMethodMapping), &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] (app(iri((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))) ((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] (app(&lt;https://linkeddatahub.com/people/Berners-Lee&gt;)) ((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) ((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))↓1 =

((reqMatch((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) = NoMatch → NotFound []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Delete → NoContent []
OK,
conNeg((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)),
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Read → merge(readData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)), state(iri((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)), paramListArgs(parameters(reqMatch((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), argumentPairs(tokenize(queryString(iri((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))))))) []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Append → empty []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Update → empty []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Delete → empty),
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Read → dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Append → merge(body((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Update → merge(body((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)), deleteData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
method((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)) = Delete → deleteData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))↓1 =

((match = NoMatch → NotFound []
Update = Delete → NoContent []
OK,
text/turtle,
Update = Read → merge(readData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)), state(&lt;https://linkeddatahub.com/people/Berners-Lee&gt;, paramListArgs(parameters(match), argumentPairs(tokenize(queryString(&lt;https://linkeddatahub.com/people/Berners-Lee&gt;)))))) []
Update = Append → empty []
Update = Update → empty []
Update = Delete → empty),
Update = Read → dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) []
Update = Append → merge(putBody, dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
Update = Update → merge(putBody, deleteData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
Update = Delete → deleteData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, deleteData((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply(delete(reqMatch((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), cons((variable(this), absolutePath(iri((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody)))), argBindings(paramListArgs(parameters(reqMatch((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), argumentPairs(tokenize(queryString(iri((Update, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;, text/trig, putBody))))))))), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply(delete(match), cons((variable(this), absolutePath(&lt;https://linkeddatahub.com/people/Berners-Lee&gt;)), argBindings(paramListArgs(parameters(match), argumentPairs(tokenize(queryString(&lt;https://linkeddatahub.com/people/Berners-Lee&gt;))))))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply(deleteWithTopic, cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(paramListArgs((graphParam), argumentPairs(tokenize("")))))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(paramListArgs((graphParam), argumentPairs(()))))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(paramListArgs((graphParam), ())))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(()))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), ())), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    ?this ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { ?this ?p ?o
        OPTIONAL
          { ?this foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", ((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;))), dataset)))↓1 =

((OK, text/turtle, empty),
merge(putBody, execDelete("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  GRAPH ?g {
    &lt;https://linkeddatahub.com/people/Berners-Lee&gt; ?p ?o .
    ?primaryTopic ?primaryTopicP ?primaryTopicO .
  }
}
WHERE
  { GRAPH ?g
      { &lt;https://linkeddatahub.com/people/Berners-Lee&gt; ?p ?o
        OPTIONAL
          { &lt;https://linkeddatahub.com/people/Berners-Lee&gt; foaf:primaryTopic ?primaryTopic .
            ?primaryTopic ?primaryTopicP ?primaryTopicO
          }
      }
  }", dataset)))↓1

(crudStatusToHTTPStatus(ldResponse↓1, crudStatusToHTTPStatusMapping), ldResponse↓2, ldResponse↓3) =

(200 OK, text/turtle, empty)</pre>
        </div>
        <div class="example">
          <p>HTTP response</p>
          <pre>HTTP/1.1 200 OK</pre>
        </div>
      </section>
      <section id="get-example">
        <h3>Read over HTTP</h3>
        <p>The following example shows how an HTTP <code>GET</code> evaluates as Linked Data <code>Read</code> request on an LDT application. The evaluation result is a successful HTTP response with a body that is an RDF dataset. The dataset is a result of a SPARQL query execution on the application dataset, augmented with hypermedia arguments.</p>
        <p>The request dereferences the IRI and retrieves the same representation that was stored by the previous example, to which the hypermedia state is
            appended.</p>
        <div class="example">
          <p>HTTP GET request <code>getRequest</code> with query string arguments</p>
          <pre>GET /people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762 HTTP/1.1
Host: linkeddatahub.com
Accept: text/turtle, text/trig</pre>
        </div>
        <div class="example">
          <p>Valuation of <code>getRequest</code></p>
          <pre>HTTPResponse [[HTTPStatus MediaType Body]] (getRequest) =

(crudStatusToHTTPStatus(ldResponse↓1, crudStatusToHTTPStatusMapping), ldResponse↓2, ldResponse↓3) : ldResponse = (LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(method(getRequest), httpMethodToCRUDMethodMapping), iri(getRequest), mediaType(getRequest), body(getRequest))))↓1

ldResponse = (LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(method(getRequest), httpMethodToCRUDMethodMapping), iri(getRequest), mediaType(getRequest), body(getRequest))))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((httpMethodToCRUDMethod(GET, httpMethodToCRUDMethodMapping), &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] (app(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))) ((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] (app(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;)) ((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

(LDResponse [[CRUDStatus RDFMediaType Dataset]] ((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) ((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))↓1 =

((reqMatch((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), app) = NoMatch → NotFound []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Delete → NoContent []
OK,
conNeg((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)),
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Read → merge(readData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)), state(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), paramListArgs(parameters(reqMatch((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), argumentPairs(tokenize(queryString(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))))))) []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Append → empty []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Update → empty []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Delete → empty),
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Read → dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Append → merge(body((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Update → merge(body((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), deleteData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
method((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)) = Delete → deleteData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))↓1 =

((match = NoMatch → NotFound []
Read = Delete → NoContent []
OK,
text/trig,
Read = Read → merge(readData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)), state(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), paramListArgs(parameters(match), argumentPairs(tokenize(queryString(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))))))) []
Read = Append → empty []
Read = Update → empty []
Read = Delete → empty),
Read = Read → dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)) []
Read = Append → merge(body((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
Read = Update → merge(body((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), deleteData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))) []
Read = Delete → deleteData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))↓1 =

((OK, text/trig,
merge(readData((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset)), state(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)), paramListArgs(parameters(match), argumentPairs(tokenize(queryString(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty))))))))),
dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset)))↓1 =

((OK, text/trig,
merge(execQuery(apply(query(reqMatch((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), cons((variable(this), absolutePath(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))), argBindings(paramListArgs(parameters(reqMatch((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty), (&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), argumentPairs(tokenize(queryString(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty))))))))), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, paramListArgs(parameters(match), argumentPairs(tokenize(queryString(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;))))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply(query(match), cons((variable(this), absolutePath(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty)))), argBindings(paramListArgs(parameters(match), argumentPairs(tokenize(queryString(iri((Read, &lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, NoType, empty))))))))), dataset((&lt;https://linkeddatahub.com/&gt;, ontology, dataset))), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, paramListArgs(parameters(match), argumentPairs(tokenize(queryString(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;))))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply(describeWithTopic, cons((?this, absolutePath(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;)), argBindings(paramListArgs((graphParam), argumentPairs(tokenize(queryString(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;))))))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, paramListArgs((graphParam), argumentPairs(tokenize("g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762")))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(paramListArgs((graphParam), argumentPairs(tokenize("g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762")))))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, paramListArgs((graphParam), (("g", "http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762")))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(paramListArgs((graphParam), argumentPairs(("g", "http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762")))))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, ((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), argBindings(((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, ((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", cons((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), ((?g, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;)))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, ((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery(apply("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE ?this ?primaryTopic
WHERE
  { GRAPH ?g
      { ?this  ?p  ?o
        OPTIONAL
          { ?this     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", ((?this, &lt;https://linkeddatahub.com/people/Berners-Lee&gt;), ((?g, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;)))), dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, ((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))),
dataset)↓1 =

((OK, text/trig,
merge(execQuery("PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DESCRIBE &lt;https://linkeddatahub.com/people/Berners-Lee&gt; ?primaryTopic
WHERE
  { GRAPH &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;
      { &lt;https://linkeddatahub.com/people/Berners-Lee&gt;  ?p  ?o
        OPTIONAL
          { &lt;https://linkeddatahub.com/people/Berners-Lee&gt;     foaf:primaryTopic  ?primaryTopic .
            ?primaryTopic
                      ?primaryTopicP     ?primaryTopicO
          }
      }
  }", dataset), state(&lt;https://linkeddatahub.com/people/Berners-Lee?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt;, ((graphParam, &gt;http://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&lt;))))),
dataset)↓1
</pre>
        </div>
        <div class="example">
          <p>HTTP response</p>
          <pre>HTTP/1.1 200 OK
Content-Type: text/trig

@base         &lt;https://linkeddatahub.com/people/Berners-Lee&gt; .
@prefix ldt:  &lt;https://www.w3.org/ns/ldt#&gt; .
@prefix c:    &lt;https://www.w3.org/ns/ldt/core/domain#&gt; .
@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt; .

&lt;../graphs/c5f34fe9-0456-48e8-a371-04be71529762&gt;
{

  &lt;&gt; a c:Document ;
    foaf:primaryTopic &lt;#this&gt; .

  &lt;#this&gt; a foaf:Person ;
    foaf:isPrimaryTopicOf &lt;&gt; ;
    owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .

}

&lt;?g=http%3A%2F%2Flinkeddatahub.com%2Fgraphs%2Fc5f34fe9-0456-48e8-a371-04be71529762&gt; ldt:arg [
  a &lt;https://linkeddatahub.com/ns#GraphParam&gt; ;
  ldt:paramName "g" ;
  rdf:value &lt;https://linkeddatahub.com/graphs/c5f34fe9-0456-48e8-a371-04be71529762&gt;
] .</pre>
        </div>
      </section>
    </section>
    <section id="vocabulary">
      <h3>Vocabulary</h3>
      <table>
        <caption>Namespaces used in this section</caption>
        <thead>
          <tr>
            <th>Prefix</th>
            <th>Namespace URI</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <code>ldt:</code>
            </td>
            <td>
              <code>https://www.w3.org/ns/ldt#</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>rdf:</code>
            </td>
            <td>
              <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>rdfs:</code>
            </td>
            <td>
              <code>http://www.w3.org/2000/01/rdf-schema#</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>xsd:</code>
            </td>
            <td>
              <code>http://www.w3.org/2001/XMLSchema#</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>sd:</code>
            </td>
            <td>
              <code>http://www.w3.org/ns/sparql-service-description#</code>
            </td>
          </tr>
        </tbody>
      </table>
      <section>
        <h4>Application</h4>
        <p class="ednote">Applications are orthogonal to operations. Does it make sense to put them under the same namespace?</p>
        <table class="core-vocab">
          <caption>Application</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th colspan="2">Range</th>
              <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a data-lt="domain-App">App</a></td>
              <td>ldt:Application</td>
              <td><strong>ldt:base</strong></td>
              <td>rdfs:Resource</td>
              <td><a data-lt="domain-IRI">IRI</a></td>
              <td>+</td>
            </tr>
            <tr>
              <td><a data-lt="domain-App">App</a></td>
              <td>ldt:Application</td>
              <td><strong>ldt:ontology</strong></td>
              <td>ldt:Ontology</td>
              <td><a data-lt="domain-Ontology">Ontology</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a data-lt="domain-App">App</a></td>
              <td>ldt:Application</td>
              <td><strong>ldt:service</strong></td>
              <td>sd:Service</td>
              <td>????</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h4>Operation</h4>
        <table class="core-vocab">
          <caption>Operation</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th colspan="2">Range</th>
              <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>ldt:match</strong></td>
              <td>xsd:string</td>
              <td><a data-lt="domain-IRIPattern">IRIPattern</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>ldt:query</strong></td>
              <td>ldt:Query</td>
              <td><a data-lt="domain-Query">Query</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>rdfs:isDefinedBy</strong></td>
              <td>ldt:Ontology</td>
              <td><a data-lt="domain-Ontology">Ontology</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:update</td>
              <td>ldt:Update</td>
              <td><a data-lt="domain-Delete">Delete</a></td>
              <td>?</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:param</td>
              <td>ldt:Parameter</td>
              <td><a data-lt="domain-Parameter">Parameter</a></td>
              <td>*</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:extends</td>
              <td>ldt:Template</td>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
        <p class="ednote">Should we align set names with RDF terms? I.e. <code>ldt:Operation</code> instead of <code>ldt:Template</code>?<br/>
            The range of the <code>rdfs:</code> properties is not accurate here in terms of RDFS.</p>

        <table class="http-vocab">
          <caption>Operation (HTTP)</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th>Range</th>
              <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:lang</td>
              <td>rdf:List(xsd:string)</td>
              <td>?</td>
            </tr>
            <tr>
              <td><a data-lt="domain-Operation">Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:cacheControl</td>
              <td>xsd:string</td>
              <td>?</td>
            </tr>
          </tbody>
        </table>
        <p class="ednote">The HTTP properties are not part of <a href="#ldt-http">LDT over HTTP</a> yet. We need to introduce HTTP headers.<br/>
            Also core and HTTP probably should not be under the same namespace.</p>
      </section>
      <section>
        <h4>Hypermedia</h4>
        <table class="core-vocab">
          <caption>Argument</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th colspan="2">Range</th>
              <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a data-lt="domain-IRI">IRI</a></td>
              <td>rdfs:Resource</td>
              <td>ldt:arg</td>
              <td></td>
              <td><a data-lt="domain-Argument">Argument</a></td>
              <td>*</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </body>
</html>
