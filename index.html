<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <title>Linked Data Templates</title>
    <script
     src='https://www.w3.org/Tools/respec/respec-w3c-common'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Martynas Jusevičius",
          url: "http://atomgraph.com",
        }],
        processVersion: 2015,
        edDraftURI: "https://github.com/AtomGraph/Linked-Data-Templates/",
        shortName: "ldt",
        wg: "Declarative Linked Data Apps Community Group",
        wgURI: "https://www.w3.org/community/declarative-apps/",
        wgPublicList: "public-declarative-apps"
      };
    </script>
    <style type="text/css">
      dt { float: left; }
      dl a.internalDFN { font-style: italic; }
      #abstract-syntax dt::after { content: "\00a0∈\00a0"; font-weight: normal; }
      #domains dt::after, #valuation-functions dt::after { content: "\00a0=\00a0"; font-weight: normal; }
      #functions dt::after { content: "\00a0:\00a0"; font-weight: normal; }
      #functions dd { font-style: italic; }
      /* #valuation-functions dt { font-weight: normal; } */
	  var { font-weight: bold; }
	  var:before { content: "?"; }
    </style>
  </head>
  <body>
    <!-- https://www.w3.org/TR/qaframe-spec/ -->
    <section id="abstract">
      <p>Linked Data Templates is a uniform protocol for read-write Linked Data. This document defines an abstract syntax (a data model) of Linked Data applications with SPARQL backends, and semantics of CRUD interactions against their resources. [[LINKED-DATA]][[sparql11-query]]</p>
    </section>
    <section id="sotd">
    </section>
    <section id="introduction" class="informative">
      <h2>Introduction</h2>
      <p>This document defines a precise semantics for Linked Data applications, providing a specification of how Create, Read, Update, Delete (CRUD) interactions change the state of their resources.</p>
      <figure id="architecture">
        <img src="images/components.svg" alt="LDT architecture">
        <figcaption>Main components of LDT architecture</figcaption>
      </figure>
      <section>
        <h3>Applications</h3>
        <p>An LDT application represents a data space identified by its base URI, in which application resource URIs are relative to the base URI. The only external interface an application provides is RESTful Linked Data: application produces RDF representations when resource URIs are dereferenced, and consumes RDF representations when requested to change resource state.</p>
      </section>
      <section>
        <h3>Services</h3>
      </section>
      <section>
        <h3>Ontologies</h3>
      </section>
    </section>
    <section id="conformance">
    </section>
    <section id="abstract-syntax">
      <h2>Abstract syntax</h2>
      <p>This section defines the data model of LDT applications.</p>
      <section id="rest">
        <h3>REST</h3>
        <p>In this section we define the abstract syntax REpresentational State Transfer. It sufficient to model a RESTful read-write API independently of the transport protocol.</p>
        <dl>
          <dt><dfn>Request</dfn></dt>
          <dd>Request</dd>
          <dt><dfn>Response</dfn></dt>
          <dd>Response</dd>
          <dt><dfn>Body</dfn></dt>
          <dd>Message-body</dd>
          <dt><dfn>MediaType</dfn></dt>
          <dd>Media-type</dd>
          <dt><dfn>Status</dfn></dt>
          <dd>Status</dd>
          <dt><dfn>IRI</dfn></dt>
          <dd>Absolute-IRI</dd>
          <dt><dfn>Method</dfn></dt>
          <dd>Interaction-method</dd>
        </dl>
        <pre class="grammar"><a>Request</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>Body</a>
<a>Response</a> := <a>Status</a> <a>Body</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
      <section id="linked-data">
        <h3>Linked Data</h3>
        <p>In this section, we specialize the REST abstract syntax by constraining the request/response representations to syntaxes of the RDF data model.</p>
        <dl>
          <dt><dfn>RDFRequest</dfn></dt>
          <dd>RDF-Request ⊂ <a>Request</a></dd>
          <dt><dfn>RDFResponse</dfn></dt>
          <dd>RDF-Response ⊂ <a>Response</a></dd>
          <dt><dfn>RDFBody</dfn></dt>
          <dd>RDF-body ⊂ <a>Body</a></dd>
          <dt><dfn>RDFMediaType</dfn></dt>
          <dd>RDF-media-type ⊂ <a>MediaType</a></dd>
		  <dt><dfn>Dataset</dfn></dt>
          <dd>RDF-dataset</dd>
        </dl><pre><a>RDFBody</a>     := <a>Dataset</a> <a>RDFMediaType</a>
<a>RDFRequest</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>RDFBody</a>
<a>RDFResponse</a> := <a>Status</a> <a>RDFBody</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
    </section>
    <section id="semantics">
      <h2>Semantics</h2>
	  <p>We use denotational semantics as the formalism.</p>
      <section id="domains">
        <h3>Domains</h3>
        <dl>
          <dt><a>IRI</a>Abs</dt>
          <dd>non-relative <a href="https://www.w3.org/TR/rdf11-concepts/#section-IRIs">IRI identifier</a> [[!rdf11-concepts]]</dd>
          <dt><a>Method</a></dt>
          <dd>{ <code>Create</code>, <code>Read</code>, <code>Delete</code>, <code>Update</code> }</dd>
		  <dt><a>Dataset</a></dt>
          <dd><a href="https://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF dataset</a> [[!rdf11-concepts]][[!sparql11-query]]</dd>
          <dt><a>RDFRequest</a></dt>
          <dd><a>Method</a> × <a>IRI</a>Abs × <a>Dataset</a></dd>
		  <dt><a>Status</a></dt>
          <dd>{ <code>NotFound</code>, <code>Created</code>, <code>NoContent</code>, <code>OK</code> }</dd>
		  <dt><dfn>Ontology</dfn></dt>
          <dd>{ <a>Operation</a>1, …, <a>Operation</a>N }</dd>
		  <!--
		  <dt><dfn>Service</a></dt>
		  <dd><a href="https://www.w3.org/TR/sparql11-service-description/#terminology">SPARQL Service</a> [[!sparql11-service-description]]</dd>
		  -->
          <dt><dfn>App</dfn></dt>
          <dd><a>IRI</a>Abs × <a>Ontology</a> × <a>Dataset</a></dd>
          <dt><dfn>QueryBinding</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#sparqlQueryVariables">Query Variable</a> × <a href="https://www.w3.org/TR/sparql11-query/#sparqlBasicTerms">RDF Term</a> [[!sparql11-query]]</dd>
          <dt><dfn>Query</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#describe">DESCRIBE</a> + <a href="https://www.w3.org/TR/sparql11-query/#construct">CONSTRUCT</a> [[!sparql11-query]]</dd>
          <dt><dfn>Update</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-update/#delete">DELETE</a> + <a href="https://www.w3.org/TR/sparql11-update/#insertData">INSERT DATA</a> [[!sparql11-update]]</dd>
          <dt><dfn>Command</dfn></dt>
          <dd><a>Query</a> + <a>Update</a></dd>
          <dt><dfn>IRIPattern</dfn></dt>
          <dd><a href="http://download.oracle.com/otn-pub/jcp/jaxrs-1.0-fr-eval-oth-JSpec/jaxrs-1.0-final-spec.pdf#page=21">URI template</a> [[!JAX-RS]]</dd>
          <dt><dfn>ReadInvocation</dfn></dt>
          <dd>{ <code>Read</code> } × <a>Query</a></dd>
          <dt><dfn>WriteInvocation</dfn></dt>
          <dd>{ <code>Create</code>, <code>Delete</code>, <code>Update</code> } × <a>Update</a></dd>
          <dt><dfn>Invocation</dfn></dt>
          <dd><a>ReadInvocation</a> + <a>WriteInvocation</a></dd>
          <dt><dfn>Operation</dfn></dt>
          <dd><a>IRIPattern</a> × <a>Invocation</a> × Priority</dd>
      </dl>
      </section>
      <section id="functions">
        <h3>Functions</h3>
        <dl>
          <dt><dfn>absolutePath</dfn></dt>
          <dd><a>IRI</a> → <a>IRI</a>Abs</dd>
          <dd>absolutePath(iri) = <a href="https://www.w3.org/TR/xpath-functions-3/#func-substring-before">fn:substring-before</a>(absoluteIri, "<code>?</code>") = absolutePath ∈ <a>IRI</a>Abs [[!xpath-functions-31]]</dd>
          <dt><dfn>method</dfn></dt>
          <dd><a>Request</a>↓1 → <a>Method</a>
          <dt><dfn>iri</dfn></dt>
          <dd><a>Request</a>↓2 → <a>IRI</a></dd>
          <dt><dfn>data</dfn></dt>
          <dd><a>RDFRequest</a>↓3 → <a>Dataset</a></dd>
          <dt><dfn>base</dfn></dt>
          <dd><a>App</a>↓1 → <a>IRI</a>
          <dt><dfn>ontology</dfn></dt>
          <dd><a>App</a>↓2 → <a>Ontology</a>
          <dt><dfn>dataset</dfn></dt>
          <dd><a>App</a>↓3 → <a>Dataset</a></dd>
          <dt><dfn>relativize</dfn></dt>
          <dd><a>IRI</a> × <a>IRI</a> → <dfn>IRIrel</dfn> ⊂ <a>IRI</a></dd>
          <dd>relativize(absoluteIri1, absoluteIri2) = relativeIri</dd>
		  <dd>The processor MUST implement <a>relativize</a> as defined in <a href="https://tools.ietf.org/html/rfc3986#section-5.2">Relative Resolution</a> [[!rfc3986]].</dd>
          <dt><dfn>app</dfn></dt>
          <dd><a>IRI</a> → <a>App</a></dd>
          <dd>app(iri) = appminPath ∈ App such that<br/>
            <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a>relativize</a>(<a>base</a>(appminPath), iri)) &#8804; <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a>relativize</a>(<a>base</a>(app), iri))<br/>
          for all app ∈ <a>App</a> : app ≠ appminPath [[xpath-functions-31]]</dd>
          <dt><dfn>context</dfn></dt>
          <dd><a>Request</a> → <a>QueryBinding</a></dd>
		  <dd>context(request) =
		    <table>
			  <thead>
			    <tr>
				  <th>Variable</th>
				  <th>RDFTerm</th>
				</tr>
			  </thead>
			  <tbody>
			    <tr>
				  <td><var>this</var></td>
				  <td><a>absolutePath</a>(<a>iri</a>(request))</td>
				</tr>
			    <tr>
				  <td><var>absolutePath</var></td>
				  <td><a>absolutePath</a>(<a>iri</a>(request))</td>
				</tr>
			    <tr>
				  <td><var>requestUri</var></td>
				  <td><a>iri</a>(request)</td>
				</tr>
			  </tbody>
			</table>
		  </dd>
          <dt><dfn>apply</dfn></dt>
          <dd><a>Command</a> × <a>QueryBinding</a> → <a>Command</a></dd>
          <dt><dfn>insertData</dfn></dt>
          <dd><a>Dataset</a>Request → <a>InsertData</a></dd>
          <dt><dfn>exec</dfn></dt>
          <dd><a>Command</a> × <a>Dataset</a>Before → <a>Dataset</a>Result × <a>Dataset</a>After
          <dt><dfn>execQuery</dfn></dt>
          <dd><a>Query</a> × <a>Dataset</a>Before → <a>Dataset</a></dd>
          <dt><dfn>execUpdate</dfn></dt>
          <dd><a>Update</a> × <a>Dataset</a>Before → <a>Dataset</a>After
          <dt><dfn>join</dfn></dt>
          <dd><a>Update</a> × <a>Update</a> → <a>Update</a>
          <dt><dfn>method</dfn></dt>
          <dd><a>Invocation</a>↓1 → <a>Method</a></dd>
          <dt><dfn>command</dfn></dt>
          <dd><a>Invocation</a>↓2 → <a>Command</a></dd>
          <dt><dfn>iriPattern</dfn></dt>
          <dd><a>Operation</a>↓1 → <a>IRIPattern</a></dd>
          <dt><dfn>invocation</dfn></dt>
          <dd><a>Operation</a>↓2 → <a>Invocation</a></dd>
          <dt><dfn>priority</dfn></dt>
          <dd><a>Operation</a>↓3 → <a>Priority</a></dd>
          <dt><dfn>matchIRIPattern</dfn></dt>
          <dd><a>IRIrel</a> × <a>IRIPattern</a> → Boolean</dd>
          <dt><dfn>matchrel</dfn></dt>
          <dd><a>IRIrel</a> × <a>Ontology</a> → <a>Operation</a></dd>
          <dd>matchrel(irirel, ontology) = operationmatch ∈ Ontology :<br/>
          		<a>matchIRIPattern</a>(irirel, <a>iriPattern</a>(operationmatch)) = <code>true</code></dd>
          <dt><dfn>match</dfn></dt>
          <dd><a>IRI</a> × <a>IRI</a>base × <a>Ontology</a> → <a>Operation</a></dd>
          <dd>match(iri, iribase, ontology) = <a>matchrel</a>(<a>relativize</a>(iribase, <a>absolutePath</a>(iri)), ontology) = operationmatch ∈ Operation</dd>
		  <dt><dfn>appMatch</dfn></dt>
		  <dd><a>IRI</a> × <a>App</a> → <a>Operation</a></dt></dd>
		  <dd>appMatch(iri, app) = <a>match</a>(iri, <a>base</a>(app), <a>ontology</a>(app))</dd></dd>
		  <dt><dfn>conneg</dfn></dt>
		  <dd><a>RDFRequest</a> → <a>RDFMediaType</a></dd>
		  <dd>The processor MUST provide an implementation of <a>conneg</a></dd>
		  <dt><dfn>created</dfn></dt>
		  <dd><a>RDFRequest</a> → <a>IRI</a></dd>
		  <dd>The processor MUST provide an implementation of <a>created</a></dd>
        </dl>
      </section>
      <section id="valuation-functions">
        <h3>Valuation functions</h3>
        <p>Evaluation of response to request ∈ <a>RDFRequest</a>:</p>
        <p>
          <dfn>RDFResponse</dfn> : <a>RDFRequest</a> × <a>Dataset</a>Before → <a>RDFResponse</a> × <a>Dataset</a>After
        </p>
        <dl>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (app) (request)</dt>
		  <dd><a>RDFResponse</a> [[<a>Status</a>]] (request) <a>RDFResponse</a> [[<a>RDFBody</a>]] (app) (request)
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (app) (request)</dt>
		  <dd><a>RDFResponse</a> [[<a>Status</a>]] (app) (request) <a>RDFResponse</a> [[<a>IRI</a>]] (app) (request)
		  <dt><a>RDFResponse</a> [[<a>Status</a>]] (app) (request)</dt>
          <dd><a>appMatch</a>(<a>iri</a>(request), app) = {} → <code>NotFound</code> []<br/>
        	 <a>method</a>(request) ∈ { <code>Create</code> } → <code>Created</code> []<br/>
             <a>method</a>(request) ∈ { <code>Delete</code> } → <code>NoContent</code> [] <code>OK</code></dd>
          <dt><a>RDFResponse</a> [[<a>RDFBody</a>]] (app) (request)</dt>
		  <dd><a>RDFResponse</a> [[<a>Dataset</a>]] (app) (request) <a>RDFResponse</a> [[<a>RDFMediaType</a>]] (app) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Dataset</a>]] (app) (request)</dt>
          <dd><a>method</a>(request) = { <code>Read</code> } → <a>execQuery</a>(<a>apply</a>(<a>command</a>(<a>invocation</a>(<a>appMatch</a>(<a>iri</a>(request), app))), <a>context</a>(<a>iri</a>(request)))) []<br/>
		    <a>execUpdate</a>(<a>join</a>(<a>apply</a>(<a>command</a>(<a>invocation</a>(<a>appMatch</a>(<a>iri</a>(request), app))), <a>context</a>(<a>iri</a>(request))), <a>insertData</a>(<a>data</a>(request))))</dd>
		  <dd class="ednote">Does not address <a>Dataset</a>After (<a>update</a> side-effects) properly. Maybe we can avoid them by defining <dfn>Service</dfn>? [[!sparql11-service-description]]</dd>
          <dt><a>RDFResponse</a> [[<a>RDFMediaType</a>]] (app) (request)</dt>
		  <dd><a>conneg</a>(request)</dd>
		  <dt><a>RDFResponse</a> [[<a>IRI</a>]] (app) (request)</dt>
		  <dd><a>method</a>(request) = { <code>Create</code> } → <a>created</a>(request) [] {}</a>
          <dt><a>IRI</a> [[<a>IRI</a>]]</dt>
          <dd><a>IRI</a></dd>
		  <dt><a>Method</a> [[<a>Method</a>]]</dt>
          <dd><a>Method</a></dd>
          <dt><a>Dataset</a> [[<a>Dataset</a>]]</dt>
          <dd><a>Dataset</a></dd>
        </dl>
      </section>
    </section>
    <section id="ldt-http">
      <h2>LDT over HTTP</h2>
      <section>
        <h3>Concrete syntax</h3>
        <p class="ednote">Link abstract syntax to HTTP ABNF?</p>
      </section>
      <section id="valuation-examples">
        <h3>Valuation examples</h3>
        <section id="get-request">
          <h4>GET request</h4>
        </section>
        <section id="post-request">
          <h4>POST request</h4>
        </section>
        <section id="put-request">
          <h4>PUT request</h4>
        </section>
        <section id="delete-request">
          <h4>DELETE request</h4>
        </section>
      </section>
    </section>
    <section id="vocabulary">
      <h3>Vocabulary</h3>
      <section id="application">
        <h4>Application</h4>
	  </section>
	  <section id="template">
        <h4>Template</h4>
        <pre><strong>ldt:Template</strong>
  rdfs:subClassOf* = rdfs:Class
  <strong>ldt:path = xsd:string</strong>
  <strong>ldt:query = ldt:Query</strong>
  ldt:update? = ldt:Update
  ldt:lang? = rdf:langString
  ldt:cacheControl? = xsd:string
  spin:constructor? = spin:Rule
  rdfs:isDefinedBy = ldt:Ontology</pre>
      </section>
    </section>
  </body>
</html>
