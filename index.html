<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <title>Linked Data Templates</title>
    <script
     src='https://www.w3.org/Tools/respec/respec-w3c-common'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "CG-DRAFT",
        editors: [{
          name: "Martynas Jusevičius",
          url: "http://atomgraph.com",
        }],
        subtitle: "Generic read-write Linked Data API",
        processVersion: 2015,
        edDraftURI: "https://github.com/AtomGraph/Linked-Data-Templates/",
        shortName: "ldt",
        wg: "Declarative Linked Data Apps Community Group",
        wgURI: "https://www.w3.org/community/declarative-apps/",
        wgPublicList: "public-declarative-apps"
      };
    </script>
    <style type="text/css">
      .abstract-syntax dt , .semantics dt { float: left; }
      .abstract-syntax .internalDFN, .semantics .internalDFN { font-style: italic; }
      .abstract-syntax dt::after { content: "\00a0∈\00a0"; font-weight: normal; }
      .domains dt::after, .valuation-functions dt::after { content: "\00a0=\00a0"; font-weight: normal; }
      .functions dt::after { content: "\00a0:\00a0"; font-weight: normal; }
      .functions dd { font-style: italic; }
      table { width: 100%; border: 1px solid black; border-collapse: collapse; }
      table th, table td { border: 1px solid black; padding: 3px; }
      table.core-vocab td:nth-child(2), table.core-vocab td:nth-child(3), table.core-vocab td:nth-child(4), table.core-vocab td:nth-child(6) { font-family: monospace; }
      table.http-vocab td:nth-child(2), table.http-vocab td:nth-child(3), table.http-vocab td:nth-child(4), table.http-vocab td:nth-child(5) { font-family: monospace; }
      var { font-weight: bold; }
    </style>
  </head>
  <body>
    <!-- https://www.w3.org/TR/qaframe-spec/ -->
    <section id="abstract">
      <p>Linked Data Templates is a uniform protocol for read-write Linked Data. This document defines an abstract syntax (a data model) of Linked Data applications with SPARQL backends, and semantics of CRUD interactions against their resources. [[LINKED-DATA]][[sparql11-overview]]</p>
    </section>
    <section id="sotd">
    </section>
    <section id="introduction" class="introductory">
      <h2>Introduction</h2>
      <p>This document defines a precise semantics for Linked Data applications, providing a specification of how Create, Read, Update, Delete (CRUD) interactions change the state of their resources.</p>
      <figure id="architecture">
        <img src="images/components.svg" alt="LDT architecture">
        <figcaption>Main components of LDT architecture</figcaption>
      </figure>
      <section>
        <h3>Applications</h3>
        <p>An LDT application represents a data space identified by its base URI, in which application resource URIs are relative to the base URI. The only interface an application provides is RESTful Linked Data: application produces RDF representations when resource URIs are dereferenced,
          and consumes RDF representations when requested to change resource state.</p>
      </section>
      <section>
        <h3>Services</h3>
        <p>A service is a datasource from which an LDT application retrieves, and in which it stores RDF data with resource representations. The only interface a service MUST provide is SPARQL 1.1 Protocol [[[!sparql11-protocol]]]. That way an application is agnostic to the service implementation
          details: it can be a native RDF triplestore, an RDBMS or XML database with an RDF wrapper, or any other compliant datasource.</p>
      </section>
      <section>
        <h3>Ontologies</h3>
        <p>An ontology is an efficient way to define application structure declaratively as a set of instructions for resource representation processing. LDT application uses a single RDF ontology to define operations specific to that application. Ontologies can be exposed and dereferenced,
          as well as imported and reused by other LDT applications or third-party software.</p>
      </section>
      <section>
        <h3>Operations</h3>
        <p>An operation maps a certain part of the application URI space to a certain SPARQL command. During request processing, an LDT processor selects a single best-matching operation (if such exists) that drives the RDF CRUD processing. Operations are defined using the
          <a href="#vocabulary">LDT vocabulary</a>, while the SPARQL commands are defined using SPIN RDF syntax.</p>
      </section>
    </section>
    <section id="conformance">
    </section>
    <section id="ldt-syntax" class="abstract-syntax">
      <h2>Abstract syntax</h2>
      <p>This section defines the data model of LDT applications.</p>
      <section id="rest-syntax">
        <h3>REST</h3>
        <p>In this section we define the abstract syntax REpresentational State Transfer. It sufficient to model a RESTful read-write API independently of the transport protocol.</p>
        <dl>
          <dt><dfn>Request</dfn></dt>
          <dd>Request</dd>
          <dt><dfn>Response</dfn></dt>
          <dd>Response</dd>
          <dt><dfn>Body</dfn></dt>
          <dd>Message-body</dd>
          <dt><dfn>MediaType</dfn></dt>
          <dd>Media-type</dd>
          <dt><dfn>Status</dfn></dt>
          <dd>Status</dd>
          <dt><dfn>IRI</dfn></dt>
          <dd>Absolute-IRI</dd>
          <dt><dfn>Method</dfn></dt>
          <dd>Interaction-method</dd>
        </dl>
        <pre class="grammar"><a>Request</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>Body</a>
<a>Response</a> := <a>Status</a> <a>Body</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
      <section id="linked-data-syntax">
        <h3>Linked Data</h3>
        <p>In this section, we specialize the REST abstract syntax by constraining the request/response representations to syntaxes of the RDF data model.</p>
        <dl>
          <dt><dfn>RDFRequest</dfn></dt>
          <dd>RDF-request ⊂ <a>Request</a></dd>
          <dt><dfn>RDFResponse</dfn></dt>
          <dd>RDF-response ⊂ <a>Response</a></dd>
          <dt><dfn>RDFBody</dfn></dt>
          <dd>RDF-body ⊂ <a>Body</a></dd>
          <dt><dfn>RDFMediaType</dfn></dt>
          <dd>RDF-media-type ⊂ <a>MediaType</a></dd>
          <dt><dfn>Dataset</dfn></dt>
          <dd>RDF-dataset</dd>
        </dl>
        <pre><a>RDFBody</a>     := <a>Dataset</a> <a>RDFMediaType</a>
<a>RDFRequest</a>  := <a>Method</a> <a>IRI</a> | <a>Method</a> <a>IRI</a> <a>RDFBody</a>
<a>RDFResponse</a> := <a>Status</a> <a>RDFBody</a> | <a>Status</a> <a>IRI</a></pre>
      </section>
    </section>
    <section id="ldt-semantics" class="semantics">
      <h2>Semantics</h2>
      <p>We use denotational semantics as the formalism.</p>
      <section id="ldt-domains" class="domains">
        <h3>Domains</h3>
        <dl>
          <dt><a>IRI</a><sub>abs</sub></dt>
          <dd>non-relative <a href="https://www.w3.org/TR/rdf11-concepts/#section-IRIs">IRI identifier</a> [[!rdf11-concepts]]</dd>
          <dt><a>Method</a></dt>
          <dd>{ <code>Create</code>, <code>Read</code>, <code>Delete</code>, <code>Update</code> }</dd>
          <dt><a>Dataset</a></dt>
          <dd><a href="https://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF dataset</a> [[!rdf11-concepts]][[!sparql11-query]]</dd>
          <dt><a>RDFRequest</a></dt>
          <dd><a>Method</a> × <a>IRI</a><sub>abs</sub> × <a>Dataset</a></dd>
          <dt><a>Status</a></dt>
          <dd>{ <code>NotFound</code>, <code>Created</code>, <code>NoContent</code>, <code>OK</code> }</dd>
          <dt><dfn>Ontology</dfn></dt>
          <dd>{ <a>Operation</a><sub>1</sub>, …, <a>Operation</a><sub>N</sub> }  × Precedence × { <a>Ontology</a><sub>1</sub>, …, <a>Ontology</a><sub>M</sub> }</dd>
              <!--
              <dt><dfn>Service</a></dt>
              <dd><a href="https://www.w3.org/TR/sparql11-service-description/#terminology">SPARQL Service</a> [[!sparql11-service-description]]</dd>
              -->
          <dt><dfn>App</dfn></dt>
          <dd><a>IRI</a> × <a>Ontology</a> × <a>Dataset</a></dd>
          <dd class="ednote">Here we define an ontology with a <a>Dataset</a>, yet the implementation/vocabulary uses a Service which is an interface for the Dataset.</dd>
    		  <dt><dfn>QueryVariable</dfn></dt>
    		  <dd><a href="https://www.w3.org/TR/sparql11-query/#sparqlQueryVariables">Query Variable</a> [[!sparql11-query]]</dd>
    		  <dt><dfn>RDFTerm</dfn></dt>
    		  <dd><a href="https://www.w3.org/TR/sparql11-query/#sparqlBasicTerms">RDF Term</a> [[!sparql11-query]]</dd>
          <dt><dfn>QueryBinding</dfn></dt>
          <dd><a>QueryVariable</a> × <a>RDFTerm</a></dd>
          <dt><dfn>Describe</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-query/#describe">DESCRIBE</a> [[!sparql11-query]]</dd>
    		  <dt><dfn>Construct</dfn></dt>
    		  <dd><a href="https://www.w3.org/TR/sparql11-query/#construct">CONSTRUCT</a> [[!sparql11-query]]</dd>
    		  <dt><dfn>Query</dfn></dt>
          <dd><a>Describe</a> + <a>Construct</a></dd>
          <dt><dfn>Delete</dfn></dt>
          <dd><a href="https://www.w3.org/TR/sparql11-update/#delete">DELETE</a> [[!sparql11-update]]</dd>
    		  <dt><dfn>InsertData</dfn></dt>
    		  <dd><a href="https://www.w3.org/TR/sparql11-update/#insertData">INSERT DATA</a> [[!sparql11-update]]</dd>
    		  <dt><dfn>Update</dfn></dt>
          <dd><a>Delete</a> + <a>InsertData</a></dd>
    		  <dt><dfn>Command</dfn></dt>
          <dd><a>Query</a> + <a>Delete</a></dd>
          <dt><dfn>IRIPattern</dfn></dt>
          <dd><a href="http://download.oracle.com/otn-pub/jcp/jaxrs-1.0-fr-eval-oth-JSpec/jaxrs-1.0-final-spec.pdf#page=21">URI template</a> [[!JAX-RS]]</dd>
          <dt><dfn>Operation</dfn></dt>
          <dd><a>IRIPattern</a> × <a>Query</a> × <a>Delete</a> × Priority<br/>
          <dt><dfn>Class</dfn></dt>
          <dd></dd>
      </dl>
      </section>
      <section id="ldt-functions" class="functions">
        <h3>Functions</h3>
        <dl>
          <dt><dfn>absolutePath</dfn></dt>
          <dd><a>IRI</a> → <a>IRI</a><sub>abs</sub></dd>
          <dd>absolutePath(iri) = <a href="https://www.w3.org/TR/xpath-functions-3/#func-substring-before">fn:substring-before</a>(absoluteIri, "<code>?</code>") = absolutePath ∈ <a>IRI</a><sub>abs</sub> [[!xpath-functions-31]]</dd>
          <dt><dfn>method</dfn></dt>
          <dd><a>Request</a>↓1 → <a>Method</a>
          <dt><dfn>iri</dfn></dt>
          <dd><a>Request</a>↓2 → <a>IRI</a></dd>
          <dt><dfn>data</dfn></dt>
          <dd><a>RDFRequest</a>↓3 → <a>Dataset</a></dd>
          <dt><dfn>operations</dfn></dt>
          <dd><a>Ontology</a>↓1 → { <a>Operation</a><sub>1</sub>, …, <a>Operation</a><sub>N</sub> }</dd>
          <dt><dfn>precedence</dfn></dt>
          <dd><a>Ontology</a>↓2 → Precedence</dd>
          <dt><dfn>imports</dfn></dt>
          <dd><a>Ontology</a>↓3 → { <a>Ontology</a><sub>1</sub>, …, <a>Ontology</a><sub>M</sub> }</dd>
          <dt><dfn>base</dfn></dt>
          <dd><a>App</a>↓1 → <a>IRI</a>
          <dt><dfn>ontology</dfn></dt>
          <dd><a>App</a>↓2 → <a>Ontology</a>
          <dt><dfn>dataset</dfn></dt>
          <dd><a>App</a>↓3 → <a>Dataset</a></dd>
          <dt><dfn>relativize</dfn></dt>
          <dd><a>IRI</a> × <a>IRI</a> → <dfn>IRI<sub>rel</sub></dfn> ⊂ <a>IRI</a></dd>
          <dd>relativize(absoluteIri1, absoluteIri2) = relativeIri</dd>
          <dd>The processor MUST implement <a>relativize</a> as defined in <a href="https://tools.ietf.org/html/rfc3986#section-5.2">Relative Resolution</a> [[!rfc3986]].</dd>
          <dt><dfn>app</dfn></dt>
          <dd><a>IRI</a> → <a>App</a></dd>
          <dd>app(iri) = appminPath ∈ App such that<br/>
            <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a>relativize</a>(<a>base</a>(appminPath), iri)) &#8804; <a href="https://www.w3.org/TR/xpath-functions-3/#func-string-length">fn:string-length</a>(<a>relativize</a>(<a>base</a>(app), iri))<br/>
          for all app ∈ <a>App</a> : app ≠ appminPath [[xpath-functions-31]]</dd>
          <dt><dfn>context</dfn></dt>
          <dd><a>Request</a> → <a>QueryBinding</a></dd>
          <dd>context(request) = (<var>?this</var>, <a>absolutePath</a>(<a>iri</a>(request)))</dd>
          <dt><dfn>apply</dfn></dt>
          <dd><a>Command</a> × <a>QueryBinding</a> → <a>Command</a></dd>
          <dt><dfn>insertData</dfn></dt>
          <dd><a>Dataset</a>Request → <a>InsertData</a></dd>
          <!--
          <dt><dfn>exec</dfn></dt>
          <dd><a>Command</a> × <a>Dataset</a><sub>before</sub> → <a>Dataset</a><sub>result</sub> × <a>Dataset</a><sub>after</sub>
          -->
          <dt><dfn>execQuery</dfn></dt>
          <dd><a>Query</a> × <a>Dataset</a><sub>before</sub> → <a>Dataset</a></dd>
          <dt><dfn>execUpdate</dfn></dt>
          <dd><a>Update</a> × <a>Dataset</a><sub>before</sub> → <a>Dataset</a><sub>after</sub>
          <dt><dfn>join</dfn></dt>
          <dd><a>Update</a> × <a>Update</a> → <a>Update</a>
          <dt><dfn>iriPattern</dfn></dt>
          <dd><a>Operation</a>↓1 → <a>IRIPattern</a></dd>
          <dt><dfn>query</dfn></dt>
          <dd><a>Operation</a>↓2 → <a>Query</a></dd>
          <dt><dfn>delete</dfn></dt>
          <dd><a>Operation</a>↓3 → <a>Delete</a></dd>
          <dt><dfn>priority</dfn></dt>
          <dd><a>Operation</a>↓4 → <a>Priority</a></dd>
          <dt><dfn>matchIRIPattern</dfn></dt>
          <dd><a>IRI</a><sub>rel</sub> × <a>IRIPattern</a> → Boolean</dd>
          <dd>The processor MUST implement <a>matchIRIPattern</a> as defined in <a href="http://download.oracle.com/otn-pub/jcp/jaxrs-2_0-fr-eval-spec/jsr339-jaxrs-2.0-final-spec.pdf#page=32">Request Matching</a>, using C = <a>Ontology</a>, T<sub>Z</sub> = <a>iriPattern</a>(operation) [[!JAX-RS]]</dd>
          <dt><dfn>matchrel</dfn></dt>
          <dd><a>IRI</a><sub>rel</sub> × <a>Ontology</a> → <a>Operation</a></dd>
          <dd>matchrel(irirel, ontology) = operationmatch ∈ Ontology :<br/>
            <a>matchIRIPattern</a>(irirel, <a>iriPattern</a>(operationmatch)) = <code>true</code></dd>
          <dt><dfn>match</dfn></dt>
          <dd><a>IRI</a> × <a>IRI</a>base × <a>Ontology</a> → <a>Operation</a></dd>
          <dd>match(iri, iribase, ontology) = <a>matchrel</a>(<a>relativize</a>(iribase, <a>absolutePath</a>(iri)), ontology) = operationmatch ∈ Operation</dd>
          <dd class="ednote">Priority and conflict resolution have not been addressed yet</dd>
          <dt><dfn>reqMatch</dfn></dt>
          <dd><a>Request</a> × <a>App</a> → <a>Operation</a></dd>
          <dd>reqMatch(request, app) = <a>match</a>(<a>iri</a>(request), <a>base</a>(app), <a>ontology</a>(app))</dd>
          <dt><dfn>type</dfn></dt>
          <dd><a>RDFTerm</a> → <a>Class</a></dd>
          <dd>type(term) = class ∈ Class</dd>
          <dt><dfn>skolemizeTerm</dfn></dt>
          <dd><a>RDFTerm</a> → <a>IRI</a></dd>
          <dd>skolemizeTerm(term) = <a href="https://www.w3.org/TR/sparql11-query/#func-isBlank">isBlank</a>(term) = <code>true</code> : build(pathTemplate(<a>type</a>(term)), propertyMap(term)) []<br/>
            term [[!sparql11-query]]</dd>
          <dd class="ednote">Skolemization definition not complete. See also <a href="https://www.w3.org/TR/rdf11-concepts/#section-skolemization">Replacing Blank Nodes with IRIs</a> [[rdf11-concepts]]</dd>
          <dt><dfn>skolemize</dfn></dt>
          <dd><a>Dataset</a> → <a>Dataset</a></dd>
          <dd>skolemize(dataset) = <a>skolemizeTerm</a>(term), term ∈ dataset</dd>
          <dt><dfn>conNeg</dfn></dt>
          <dd><a>Request</a> → <a>MediaType</a></dd>
          <dd>The processor MUST implement <a>conNeg</a> as defined in <a href="http://download.oracle.com/otn-pub/jcp/jaxrs-1.0-fr-eval-oth-JSpec/jaxrs-1.0-final-spec.pdf#page=28">Determining the MediaType of Responses</a> [[!JAX-RS]]</dd>
          <dt><dfn>created</dfn></dt>
          <dd><a>RDFRequest</a> → <a>IRI</a></dd>
          <dd>created(rdfRequest) = iri ∈ <a>skolemize</a>(<a>data</a>(rdfRequest))</dd>
          <dd>The processor MUST provide an implementation of <a>created</a> that satisfies the above definition</dd>
        </dl>
      </section>
      <section id="ldt-valuation" class="valuation-functions">
        <h3>Valuation functions</h3>
        <p>Evaluation of response to request ∈ <a>RDFRequest</a>:</p>
        <p>
          <dfn>RDFResponse</dfn> : <a>RDFRequest</a> × <a>Dataset</a><sub>before</sub> → <a>RDFResponse</a> × <a>Dataset</a><sub>after</sub>
        </p>
        <dl>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>RDFBody</a>]] (app) (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a>]] (app) (request) <a>RDFResponse</a> [[<a>RDFBody</a>]] (app) (request)
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Status</a> <a>IRI</a>]] (app) (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a>]] (app) (request) <a>RDFResponse</a> [[<a>IRI</a>]] (app) (request)
          <dt><a>RDFResponse</a> [[<a>Status</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Status</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Status</a>]] (app) (request)</dt>
          <dd><a>reqMatch</a>(request, app) = {} → <code>NotFound</code> []<br/>
             <a>method</a>(request) = <code>Create</code> → <code>Created</code> []<br/>
             <a>method</a>(request) = <code>Delete</code> → <code>NoContent</code> []<br/>
             <code>OK</code>
          </dd>
          <dt><a>RDFResponse</a> [[<a>RDFBody</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>RDFBody</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>RDFBody</a>]] (app) (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Dataset</a>]] (app) (request) <a>RDFResponse</a> [[<a>RDFMediaType</a>]] (app) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Dataset</a>]] (request)</dt>
          <dd><a>RDFResponse</a> [[<a>Dataset</a>]] (<a>app</a>(<a>iri</a>(request))) (request)</dd>
          <dt><a>RDFResponse</a> [[<a>Dataset</a>]] (app) (request)</dt>
          <dd><a>method</a>(request) = <code>Read</code>  → <a>execQuery</a>(<a>apply</a>(<a>query</a>(<a>reqMatch</a>(request, app)), <a>context</a>(<a>iri</a>(request)))) []<br/>
            <a>method</a>(request) = <code>Create</code> → <a>execUpdate</a>(<a>insertData</a>(<a>skolemize</a>(<a>data</a>(request)))) []<br/>
              <a>method</a>(request) = <code>Update</code> → <a>execUpdate</a>(<a>join</a>(<a>apply</a>(<a>delete</a>(<a>reqMatch</a>(request, app)), <a>context</a>(<a>iri</a>(request))), <a>insertData</a>(<a>data</a>(request)))) []<br/>
                <a>method</a>(request) = <code>Delete</code> → <a>execUpdate</a>(<a>apply</a>(<a>delete</a>(<a>reqMatch</a>(request, app)), <a>context</a>(<a>iri</a>(request)))) []<br/>
            {}</dd>
          <dd class="ednote">Does this address <a>Dataset</a><sub>after</sub> (<a>update</a> side-effects) properly? Maybe we can avoid them by defining <dfn>Service</dfn>? [[!sparql11-service-description]]</dd>
          <dt><a>RDFResponse</a> [[<a>RDFMediaType</a>]] (app) (request)</dt>
		  <dd><a>conNeg</a>(request)</dd>
		  <dt><a>RDFResponse</a> [[<a>IRI</a>]] (app) (request)</dt>
		  <dd><a>method</a>(request) = <code>Create</code> → <a>created</a>(request) []<br/>
			{}</dd>
        </dl>
      </section>
    </section>
    <section id="ldt-http">
      <h2>LDT over HTTP</h2>
      <section id="http-syntax" class="abstract-syntax">
        <h3>Abstract syntax</h3>
        <dl>
          <dt><dfn>HTTPRequest</dfn></dt>
          <dd>HTTP-request</dd>
          <dt><dfn>HTTPResponse</dfn></dt>
          <dd>HTTP-response</dd>
          <dt><dfn>HTTPStatus</dfn></dt>
          <dd>HTTP-status</dd>
          <dt><dfn>HTTPMethod</dfn></dt>
          <dd>HTTP-method</dd>
        </dl>
        <pre><a>HTTPRequest</a>  := <a>HTTPMethod</a> <a>IRI</a> | <a>HTTPMethod</a> <a>IRI</a> <a>Body</a>
<a>HTTPResponse</a> := <a>HTTPStatus</a> <a>Body</a> | <a>HTTPStatus</a> <a>IRI</a></pre>
      </section>
      <section id="http-semantics" class="semantics">
        <h3>Semantics</h3>
        <section id="http-domains" class="domains">
          <h4>Domains</h4>
          <dl>
            <dt><dfn>HTTPRequest</dfn></dt>
            <dd><a>HTTPMethod</a> × <a>IRI</a><sub>abs</sub> × <a>Body</a></dd>
            <dt><dfn>HTTPResponse</dfn></dt>
            <dd><a>HTTPMethod</a> × <a>IRI</a><sub>abs</sub> × <a>Body</a></dd>
            <dt><dfn>HTTPStatus</dfn></dt>
            <dd>{ <code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code>, <code>404 Not Found</code>, <code>405 Method Not Allowed</code>, <code>406 Not Acceptable</code> } ⊂ <a href="https://tools.ietf.org/html/rfc7231#section-6">Response Status Codes</a> [[!HTTP11]]</dd>
            <dt><dfn>HTTPMethod</dfn></dt>
            <dd>{ <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> } ⊂ <a href="https://tools.ietf.org/html/rfc7231#section-4">Request Methods</a> [[!HTTP11]]</dd>
          </dl>
        </section>
        <section id="http-functions" class="functions">
          <h4>Functions</h4>
          <dl>
            <dt><dfn>httpMethod</dfn></dt>
            <dd><a>HTTPRequest</a>↓1 → <a>HTTPMethod</a></dd>
            <dt><dfn>httpIri</dfn></dt>
            <dd><a>HTTPRequest</a>↓2 → <a>IRI</a></dd>
            <dt><dfn>httpBody</dfn></dt>
            <dd><a>HTTPRequest</a>↓3 → <a>Body</a></dd>
            <dt><dfn>httpMethodToMethod</dfn></dt>
            <dd><a>HTTPMethod</a> → <a>Method</a></dd>
            <dd>httpMethodToMethod(httpMethod) = httpMethod = <code>POST</code> → <code>Create</code> []<br/>
              httpMethod = <code>GET</code> → <code>Read</code> []<br/>
              httpMethod = <code>PUT</code> → <code>Update</code> []<br/>
              httpMethod = <code>DELETE</code> → <code>Delete</code> []<br/>
              {}</dd>
            <dt><dfn>statusToHttpStatus</dfn></dt>
            <dd><a>Status</a> → <a>HTTPStatus</a></dd>
            <dd>statusToHttpStatus(status) = status = <code>NotFound</code> → <code>404 Not Found</code> []<br/>
              status = <code>Created</code> → <code>201 Created</code> []<br/>
              status = <code>NoContent</code> → <code>204 No Content</code> []<br/>
              status = <code>OK</code> → <code>200 OK</code> []<br/>
              {}</dd>
          </dl>
        </section>
        <section id="http-valuation" class="valuation-functions">
          <h3>Valuation functions</h3>
          <p>Evaluation of response to request ∈ <a>HTTPRequest</a>:</p>
          <p>
            <dfn>HTTPResponse</dfn> : <a>HTTPRequest</a> → <a>HTTPResponse</a>
          </p>
          <dl>
            <dt><a>HTTPResponse</a> [[<a>HTTPStatus</a> <a>Body</a>]] (httpRequest)</dt>
            <dd><a>HTTPResponse</a> [[<a>HTTPStatus</a>]] (httpRequest) <a>HTTPResponse</a> [[<a>Body</a>]] (httpRequest)</dd>
            <dt><a>HTTPResponse</a> [[<a>HTTPStatus</a> <a>IRI</a>]] (httpRequest)</dt>
            <dd><a>HTTPResponse</a> [[<a>HTTPStatus</a>]] (httpRequest) <a>HTTPResponse</a> [[<a>IRI</a>]] (httpRequest)</dd>
            <dt><a>HTTPResponse</a> [[<a>HTTPStatus</a>]] (httpRequest)</dt>
            <dd><a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)) = {} → <code>405 Method Not Allowed</code> []<br/>
              <a>httpBody</a>(httpRequest) ∉ <a>RDFBody</a> → <code>406 Not Acceptable</code> []<br/>
              <a>statusToHttpStatus</a>(<a>RDFResponse</a> [[<a>Status</a>]] ((<a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)), <a>httpIri</a>(httpRequest), <a>httpBody</a>(httpRequest))))
            </dd>
            <dt><a>HTTPResponse</a> [[<a>Body</a>]] (httpRequest)</dt>
            <dd><a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)) = {} → {} []<br/>
              <a>httpBody</a>(httpRequest) ∉ <a>RDFBody</a> → {} []<br/>
              <a>RDFResponse</a> [[<a>RDFBody</a>]] (<a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)), <a>httpIri</a>(httpRequest), <a>httpBody</a>(httpRequest))
            </dd>
            <dt><a>HTTPResponse</a> [[<a>IRI</a>]] (httpRequest)</dt>
            <dd><a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)) = {} → {} []<br/>
              <a>RDFResponse</a> [[<a>IRI</a>]] (<a>httpMethodToMethod</a>(<a>httpMethod</a>(httpRequest)), <a>httpIri</a>(httpRequest), <a>httpBody</a>(httpRequest))
            </dd>
          </dl>
        </section>
      </section>
    </section>
    <section id="examples">
      <h3>Examples</h3>
      <p>
          We will use the following set members for all the subsequent response valuation examples:
      </p>
      <dl class="domains">
        <dt><code>app</code> ∈ <a>App</a></dt>
        <dd><a>app</a>(<a>iri</a>(request)) = (<code>&lt;http://linkeddatahub.com/&gt;</code>, <code>ontology</code>, <code>dataset</code>)</dd>
        <dt><code>match</code> ∈ <a>Operation</a></dt>
        <dd><a>reqMatch</a>(request, app) = (<code>"/people/{familyName}"</code>, <code>describeWithTopic</code>, <code>deleteWithTopic</code>, <code>0</code>)</dd>
        <dt><code>deleteWithTopic</code> ∈ <a>Delete</a></dt>
        <dd><pre><code>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  ?this ?p ?o .
  ?primaryTopic ?primaryTopicP ?primaryTopicO .
}
WHERE
  { ?this ?p ?o
    OPTIONAL
      { ?this foaf:primaryTopic ?primaryTopic .
        ?primaryTopic ?primaryTopicP ?primaryTopicO
      }
  }</code></pre></dd>
      </dl>
      <section id="put-example">
        <h4>Update over HTTP</h4>
        <div class="example">
          <p>HTTP PUT request <code>putRequest</code> with request body <code>putBody</code></p>
          <pre>PUT /people/Berners-Lee HTTP/1.1
Host: linkeddatahub.com
Accept: text/turtle
Content-Type: text/turtle

@base         &lt;http://linkeddatahub.com/people/Berners-Lee&gt; .
@prefix ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt; .

&lt;&gt; a ldtc:Document ;
  foaf:primaryTopic &lt;#this&gt; .

&lt;#this&gt; a foaf:Person ;
  foaf:isPrimaryTopicOf &lt;&gt; ;
  owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .</pre>
        </div>
        <div class="example">
          <p>Valuation of <code>putRequest</code></p>
          <pre>HTTPResponse [[HTTPStatus Body]] (<code>putRequest</code>) = HTTPResponse [[HTTPStatus]] (<code>putRequest</code>) HTTPResponse [[Body]] (<code>putRequest</code>) =

statusToHttpStatus(RDFResponse [[Status]] ((httpMethodToMethod(httpMethod(<code>putRequest</code>)), httpIri(<code>putRequest</code>), httpBody(<code>putRequest</code>))))
RDFResponse [[RDFBody]] (httpMethodToMethod(httpMethod(<code>putRequest</code>)), httpIri(<code>putRequest</code>), httpBody(<code>putRequest</code>)) =

statusToHttpStatus(RDFResponse [[Status]] ((httpMethodToMethod(<code>PUT</code>), <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))
RDFResponse [[RDFBody]] (httpMethodToMethod(<code>PUT</code>), <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>) =

statusToHttpStatus(RDFResponse [[Status]] ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))
RDFResponse [[RDFBody]] (<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>) =

statusToHttpStatus(RDFResponse [[Status]] (app(iri((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))
RDFResponse [[RDFBody]] (app(iri((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) =

statusToHttpStatus(RDFResponse [[Status]] (app(<code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>)) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))
RDFResponse [[RDFBody]] (app(<code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>)) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) =

statusToHttpStatus(RDFResponse [[Status]] (<code>app</code>) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))
RDFResponse [[RDFBody]] (<code>app</code>) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) =

<code>200 OK</code> RDFResponse [[Dataset]] (<code>app</code>) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) RDFResponse [[RDFMediaType]] (<code>app</code>) ((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) =

<code>200 OK</code> execUpdate(join(apply(delete(reqMatch((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>), <code>app</code>)), context(iri((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)))), insertData(data((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>))))) conNeg((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>)) =

<code>200 OK</code> execUpdate(join(apply(delete(<code>match</code>), (<code>?this</code>, absolutePath(iri((<code>Update</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>, <code>putBody</code>))))), insertData(<code>putBody</code>))) <code>text/turtle</code> =

<code>200 OK</code> execUpdate(join(apply(delete((<code>"/people/{familyName}"</code>, (<code>describeWithTopic</code>, <code>deleteWithTopic</code>), <code>0</code>)), (<code>?this</code>, absolutePath(<code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>))), <code>BASE    &lt;http://linkeddatahub.com/&gt;
PREFIX  ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt;
PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

INSERT DATA {
  &lt;people/Berners-Lee&gt; a ldtc:Document .
  &lt;people/Berners-Lee&gt; foaf:primaryTopic &lt;people/Berners-Lee#this&gt; .
  &lt;people/Berners-Lee#this&gt; a foaf:Person .
  &lt;people/Berners-Lee#this&gt; foaf:isPrimaryTopicOf &lt;people/Berners-Lee&gt; .
  &lt;people/Berners-Lee#this&gt; owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .
}</code>)) <code>text/turtle</code> =

<code>200 OK</code> execUpdate(join(apply(<code>deleteWithTopic</code>, (<code>?this</code>, absolutePath(<code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>))), <code>BASE    &lt;http://linkeddatahub.com/&gt;
PREFIX  ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt;
PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

INSERT DATA {
  &lt;people/Berners-Lee&gt; a ldtc:Document .
  &lt;people/Berners-Lee&gt; foaf:primaryTopic &lt;people/Berners-Lee#this&gt; .
  &lt;people/Berners-Lee#this&gt; a foaf:Person .
  &lt;people/Berners-Lee#this&gt; foaf:isPrimaryTopicOf &lt;people/Berners-Lee&gt; .
  &lt;people/Berners-Lee#this&gt; owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .
}</code>)) <code>text/turtle</code> =

<code>200 OK</code> execUpdate(join(apply(<code>deleteWithTopic</code>, (<code>?this</code>, <code>&lt;http://linkeddatahub.com/people/Berners-Lee&gt;</code>)), <code>BASE    &lt;http://linkeddatahub.com/&gt;
PREFIX  ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt;
PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

INSERT DATA {
  &lt;people/Berners-Lee&gt; a ldtc:Document .
  &lt;people/Berners-Lee&gt; foaf:primaryTopic &lt;people/Berners-Lee#this&gt; .
  &lt;people/Berners-Lee#this&gt; a foaf:Person .
  &lt;people/Berners-Lee#this&gt; foaf:isPrimaryTopicOf &lt;people/Berners-Lee&gt; .
  &lt;people/Berners-Lee#this&gt; owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .
}</code>)) <code>text/turtle</code> =

<code>200 OK</code> execUpdate(join(<code>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  ?this ?p ?o .
  ?primaryTopic ?primaryTopicP ?primaryTopicO .
}
WHERE
  { ?this ?p ?o
    OPTIONAL
      { ?this foaf:primaryTopic ?primaryTopic .
        ?primaryTopic ?primaryTopicP ?primaryTopicO
      }
  }</code>, <code>BASE    &lt;http://linkeddatahub.com/&gt;
  PREFIX  ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt;
  PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
  PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

  INSERT DATA {
    &lt;people/Berners-Lee&gt; a ldtc:Document .
    &lt;people/Berners-Lee&gt; foaf:primaryTopic &lt;people/Berners-Lee#this&gt; .
    &lt;people/Berners-Lee#this&gt; a foaf:Person .
    &lt;people/Berners-Lee#this&gt; foaf:isPrimaryTopicOf &lt;people/Berners-Lee&gt; .
    &lt;people/Berners-Lee#this&gt; owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .
  }</code>)) <code>text/turtle</code> =

<code>200 OK</code> execUpdate(<code>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

DELETE {
  ?this ?p ?o .
  ?primaryTopic ?primaryTopicP ?primaryTopicO .
}
WHERE
  { ?this ?p ?o
    OPTIONAL
      { ?this foaf:primaryTopic ?primaryTopic .
        ?primaryTopic ?primaryTopicP ?primaryTopicO
      }
  } ;

  BASE    &lt;http://linkeddatahub.com/&gt;
  PREFIX  ldtc: &lt;http://www.w3.org/ns/ldt/core#&gt;
  PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
  PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

  INSERT DATA {
    &lt;people/Berners-Lee&gt; a ldtc:Document .
    &lt;people/Berners-Lee&gt; foaf:primaryTopic &lt;people/Berners-Lee#this&gt; .
    &lt;people/Berners-Lee#this&gt; a foaf:Person .
    &lt;people/Berners-Lee#this&gt; foaf:isPrimaryTopicOf &lt;people/Berners-Lee&gt; .
    &lt;people/Berners-Lee#this&gt; owl:sameAs &lt;https://www.w3.org/People/Berners-Lee/card#i&gt; .
  }</code>) <code>text/turtle</code></pre>
        </div>
        <div class="example">
          <p>HTTP response</p>
          <pre>200 OK</pre>
        </div>
      </section>
    </section>
    <section id="vocabulary">
      <h3>Vocabulary</h3>
	  <p>The namespace URI of the LDT vocabulary is <code>http://www.w3.org/ns/ldt#</code>.</p>	
      <section>
        <h4>Application</h4>
		<p class="ednote">Applications are orthogonal to templates. Does it make sense to put them under the same namespace?</p>	
      </section>
      <section>
        <h4>Template</h4>
        <table class="core-vocab">
          <caption>Core</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th colspan="2">Range</th>
			  <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>ldt:path</strong></td>
              <td>xsd:string</td>
              <td><a>IRIPattern</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>ldt:query</strong></td>
              <td>ldt:Query</td>
              <td><a>Query</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td><strong>rdfs:isDefinedBy</strong></td>
              <td>ldt:Ontology</td>
              <td><a>Ontology</a></td>
              <td>1</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:update</td>
              <td>ldt:Update</td>
              <td><a>Update</a></td>
              <td>?</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:param</td>
              <td>ldt:Argument</td>
              <td><a>Argument</a></td>
              <td>*</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td>rdfs:subClassOf</td>
              <td>rdfs:Class</td>
              <td><a>Operation</a></td>
              <td>*</td>
            </tr>
          </tbody>
        </table>
		<p class="ednote">Should we align set names with RDF terms? I.e. <code>ldt:Operation</code> instead of <code>ldt:Template</code>?<br/>
			The range of the <code>rdfs:</code> properties is not accurate here in terms of RDFS.</p>

        <table class="http-vocab">
          <caption>HTTP</caption>
          <thead>
            <tr>
              <th colspan="2">Domain</th>
              <th>Property</th>
              <th>Range</th>
			  <th>Cardinality</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:lang</td>
              <td>rdf:List(xsd:string)</td>
              <td>?</td>
            </tr>
            <tr>
              <td><a>Operation</a></td>
              <td>ldt:Template</td>
              <td>ldt:cacheControl</td>
              <td>xsd:string</td>
              <td>?</td>
            </tr>
          </tbody>
        </table>
		<p class="ednote">The HTTP properties are not part of <a href="#ldt-http">LDT over HTTP</a> yet. We need to introduce HTTP headers.<br/>
			Also core and HTTP probably should not be under the same namespace.</p>
      </section>
    </section>
  </body>
</html>
